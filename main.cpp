#define GLFW_INCLUDE_VULKAN
#include <GLFW/glfw3.h>

#include <glm/glm.hpp>

#include <iostream>
#include <fstream>
#include <stdexcept>
#include <algorithm>
#include <vector>
#include <cstring>
#include <cstdlib>
#include <cstdint>
#include <limits>
#include <array>
#include <optional>
#include <set>
#include <cmath>

//  using a structure like this:
//
//  vkAcquireNextImageKHR, vkBeginCommandBuffer, vkCmdBeginRenderPass,
//
//  change vertex data(drew a cube and rotate / move it around with mouse / wasd),
//
//  vkBindBufferMemory, vkMapMemory, vkUnmapMemory, vkCmdBindPipeline, vkCmdBindVertexBuffers, vkCmdDraw(or indexdraw), vkCmdEndRenderPass, vkEndCommandBuffer, vkQueueSubmit, vkQueuePresentKHR, vkQueueWaitIdle(queue);
//
//  ofcourse all these commands need the createinfo structures or something similar.

const uint32_t WIDTH = 1920;
const uint32_t HEIGHT = 1080;

const int MAX_FRAMES_IN_FLIGHT = 1;

const std::vector<const char*> validationLayers = {
    "VK_LAYER_KHRONOS_validation"
};

const std::vector<const char*> deviceExtensions = {
    VK_KHR_SWAPCHAIN_EXTENSION_NAME
};

#ifdef NDEBUG
const bool enableValidationLayers = false;
#else
const bool enableValidationLayers = true;
#endif

VkResult CreateDebugUtilsMessengerEXT(VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT* pDebugMessenger) {
    auto func = (PFN_vkCreateDebugUtilsMessengerEXT)vkGetInstanceProcAddr(instance, "vkCreateDebugUtilsMessengerEXT");
    if (func != nullptr) {
        return func(instance, pCreateInfo, pAllocator, pDebugMessenger);
    }
    else {
        return VK_ERROR_EXTENSION_NOT_PRESENT;
    }
}

void DestroyDebugUtilsMessengerEXT(VkInstance instance, VkDebugUtilsMessengerEXT debugMessenger, const VkAllocationCallbacks* pAllocator) {
    auto func = (PFN_vkDestroyDebugUtilsMessengerEXT)vkGetInstanceProcAddr(instance, "vkDestroyDebugUtilsMessengerEXT");
    if (func != nullptr) {
        func(instance, debugMessenger, pAllocator);
    }
}

struct QueueFamilyIndices {
    std::optional<uint32_t> graphicsFamily;
    std::optional<uint32_t> presentFamily;

    bool isComplete() {
        return graphicsFamily.has_value() && presentFamily.has_value();
    }
};

struct SwapChainSupportDetails {
    VkSurfaceCapabilitiesKHR capabilities;
    std::vector<VkSurfaceFormatKHR> formats;
    std::vector<VkPresentModeKHR> presentModes;
};

struct Vertex {
    glm::vec2 pos;
    glm::vec3 color;

    static VkVertexInputBindingDescription getBindingDescription() {
        VkVertexInputBindingDescription bindingDescription{};
        bindingDescription.binding = 0;
        bindingDescription.stride = sizeof(Vertex);
        bindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;

        return bindingDescription;
    }

    static std::array<VkVertexInputAttributeDescription, 2> getAttributeDescriptions() {
        std::array<VkVertexInputAttributeDescription, 2> attributeDescriptions{};

        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 0;
        attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[0].offset = offsetof(Vertex, pos);

        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 1;
        attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = offsetof(Vertex, color);

        return attributeDescriptions;
    }
};


struct DrawnObject {
    std::string name;
    std::vector<Vertex> vertices;
    std::vector<uint32_t> indices;

};

struct BufferMemoryStruct {
    VkBuffer Buffer;
    VkDeviceMemory Memory;
};
std::vector<Vertex> vertices = {
    //canvas
    //1
    {{-1.0f, -1.0f}, {1.0f, 1.0f, 1.0f}},
    {{1.0f, -1.0f}, {1.0f, 1.0f, 1.0f}},
    {{1.0f, 1.0f}, {1.0f, 1.0f, 1.0f}},
    {{-1.0f, 1.0f}, {1.0f, 1.0f, 1.0f}},
    // uiblock
    //2
    {{0.6f, -1.0f}, {0.4f, 0.6f, 0.4f}},
    {{1.0f, -1.0f}, {0.4f, 0.6f, 0.4f}},
    {{1.0f, 1.0f}, {0.4f, 0.6f, 0.4f}},
    {{0.6f, 1.0f}, {0.4f, 0.6f, 0.4f}},
    // colourOutlines 1
    //3
    {{0.62f, -0.98f}, {0.0f, 0.0f, 0.0f}},
    {{0.7f, -0.98f},{0.0f, 0.0f, 0.0f}},
    {{0.7f, -0.9f}, {0.0f, 0.0f, 0.0f}},
    {{0.62f, -0.9f}, {0.0f, 0.0f, 0.0f}},
    //4
    {{0.71f, -0.98f}, {1.0f, 1.0f, 1.0f}},
    {{0.79f, -0.98f},{1.0f, 1.0f, 1.0f}},
    {{0.79f, -0.9f}, {1.0f, 1.0f, 1.0f}},
    {{0.71f, -0.9f}, {1.0f, 1.0f, 1.0f}},
    //5
    {{0.8f, -0.98f}, {0.0f, 0.0f, 0.0f}},
    {{0.88f, -0.98f},{0.0f, 0.0f, 0.0f}},
    {{0.88f, -0.9f}, {0.0f, 0.0f, 0.0f}},
    {{0.8f, -0.9f}, {0.0f, 0.0f, 0.0f}},
    //6
    {{0.89f, -0.98f}, {0.0f, 0.0f, 0.0f}},
    {{0.97f, -0.98f},{0.0f, 0.0f, 0.0f}},
    {{0.97f, -0.9f}, {0.0f, 0.0f, 0.0f}},
    {{0.89f, -0.9f}, {0.0f, 0.0f, 0.0f}},

    // colourOutlines 2
    //7
    {{0.62f, -0.89f}, {0.0f, 0.0f, 0.0f}},
    {{0.7f, -0.89f},{0.0f, 0.0f, 0.0f}},
    {{0.7f, -0.81f}, {0.0f, 0.0f, 0.0f}},
    {{0.62f, -0.81f}, {0.0f, 0.0f, 0.0f}},
    //8
    {{0.71f, -0.89f}, {0.0f, 0.0f, 0.0f}},
    {{0.79f, -0.89f},{0.0f, 0.0f, 0.0f}},
    {{0.79f, -0.81}, {0.0f, 0.0f, 0.0f}},
    {{0.71f, -0.81}, {0.0f, 0.0f, 0.0f}},
    //9
    {{0.8f, -0.89f}, {0.0f, 0.0f, 0.0f}},
    {{0.88f, -0.89f},{0.0f, 0.0f, 0.0f}},
    {{0.88f, -0.81f}, {0.0f, 0.0f, 0.0f}},
    {{0.8f, -0.81f}, {0.0f, 0.0f, 0.0f}},
    //10
    {{0.89f, -0.89f}, {0.0f, 0.0f, 0.0f}},
    {{0.97f, -0.89f},{0.0f, 0.0f, 0.0f}},
    {{0.97f, -0.81f}, {0.0f, 0.0f, 0.0f}},
    {{0.89f, -0.81f}, {0.0f, 0.0f, 0.0f}},

    // colourOutlines 3
    //11
    {{0.62f, -0.8f}, {0.0f, 0.0f, 0.0f}},
    {{0.7f, -0.8f},{0.0f, 0.0f, 0.0f}},
    {{0.7f, -0.72f}, {0.0f, 0.0f, 0.0f}},
    {{0.62f, -0.72f}, {0.0f, 0.0f, 0.0f}},
    //12
    {{0.71f, -0.8f}, {0.0f, 0.0f, 0.0f}},
    {{0.79f, -0.8f},{0.0f, 0.0f, 0.0f}},
    {{0.79f, -0.72f}, {0.0f, 0.0f, 0.0f}},
    {{0.71f, -0.72f}, {0.0f, 0.0f, 0.0f}},
    //13
    {{0.8f, -0.8f}, {0.0f, 0.0f, 0.0f}},
    {{0.88f, -0.8f},{0.0f, 0.0f, 0.0f}},
    {{0.88f, -0.72f}, {0.0f, 0.0f, 0.0f}},
    {{0.8f, -0.72f}, {0.0f, 0.0f, 0.0f}},
    //14
    {{0.89f, -0.8f}, {0.0f, 0.0f, 0.0f}},
    {{0.97f, -0.8f},{0.0f, 0.0f, 0.0f}},
    {{0.97f, -0.72f}, {0.0f, 0.0f, 0.0f}},
    {{0.89f, -0.72f}, {0.0f, 0.0f, 0.0f}},

    // colourOutlines 4
    //15
    {{0.62f, -0.71f}, {0.0f, 0.0f, 0.0f}},
    {{0.7f, -0.71f},{0.0f, 0.0f, 0.0f}},
    {{0.7f, -0.63f}, {0.0f, 0.0f, 0.0f}},
    {{0.62f, -0.63f}, {0.0f, 0.0f, 0.0f}},
    //16
    {{0.71f, -0.71f}, {0.0f, 0.0f, 0.0f}},
    {{0.79f, -0.71f},{0.0f, 0.0f, 0.0f}},
    {{0.79f, -0.63f}, {0.0f, 0.0f, 0.0f}},
    {{0.71f, -0.63f}, {0.0f, 0.0f, 0.0f}},
    //17
    {{0.8f, -0.71f}, {0.0f, 0.0f, 0.0f}},
    {{0.88f, -0.71f},{0.0f, 0.0f, 0.0f}},
    {{0.88f, -0.63f}, {0.0f, 0.0f, 0.0f}},
    {{0.8f, -0.63f}, {0.0f, 0.0f, 0.0f}},
    //18
    {{0.89f, -0.71f}, {0.0f, 0.0f, 0.0f}},
    {{0.97f, -0.71f},{0.0f, 0.0f, 0.0f}},
    {{0.97f, -0.63f}, {0.0f, 0.0f, 0.0f}},
    {{0.89f, -0.63f}, {0.0f, 0.0f, 0.0f}},

    ////colours 1
    {{0.625f, -0.97f}, {1.0f, 1.0f, 1.0f}},
    {{0.695f, -0.97f},{1.0f, 1.0f, 1.0f}},
    {{0.695f, -0.91f}, {1.0f, 1.0f, 1.0f}},
    {{0.625f, -0.91f}, {1.0f, 1.0f, 1.0f}},

    {{0.715f, -0.97f}, {0.0f, 0.0f, 0.0f}}, 
    {{0.785f, -0.97f},{0.0f, 0.0f, 0.0f}},
    {{0.785f, -0.91f}, {0.0f, 0.0f, 0.0f}},
    {{0.715f, -0.91f}, {0.0f, 0.0f, 0.0f}},

    {{0.805f, -0.97f}, {0.6274f, 0.6274f, 0.6274f}},
    {{0.875f, -0.97f}, {0.6274f, 0.6274f, 0.6274f} },
    { {0.875f, -0.91f}, {0.6274f, 0.6274f, 0.6274f} },
    { {0.805f, -0.91f}, {0.6274f, 0.6274f, 0.6274f}},

    {{0.895f, -0.97f}, {0.34117f, 0.34117f, 0.34117f}},
    {{0.965f, -0.97f}, {0.34117f, 0.34117f, 0.34117f} },
    { {0.965f, -0.91f}, {0.34117f, 0.34117f, 0.34117f} },
    { {0.895f, -0.91f}, {0.34117f, 0.34117f, 0.34117f}},

    ////colours 2
    { {0.625f, -0.882f}, {0.1647f, 0.29411f, 0.84313} },
    { {0.695f, -0.882f}, {0.1647f, 0.29411f, 0.84313} },
    { {0.695f, -0.818f}, {0.1647f, 0.29411f, 0.84313} },
    { {0.625f, -0.818f}, {0.1647f, 0.29411f, 0.84313} },

    { {0.715f, -0.882f}, {0.11372f, 0.41176f, 0.07843f} },
    { {0.785f, -0.882f}, {0.11372f, 0.41176f, 0.07843f} },
    { {0.785f, -0.818f}, {0.11372f, 0.41176f, 0.07843f} },
    { {0.715f, -0.818f}, {0.11372f, 0.41176f, 0.07843f} },

    { {0.805f, -0.882f}, {0.50588f, 0.29019f, 0.09803f} },
    { {0.875f, -0.882f}, {0.50588f, 0.29019f, 0.09803f} },
    { {0.875f, -0.818f}, {0.50588f, 0.29019f, 0.09803f} },
    { {0.805f, -0.818f}, {0.50588f, 0.29019f, 0.09803f} },

    { {0.895f, -0.882f}, {0.50588f, 0.14901f, 0.75294f} },
    { {0.965f, -0.882f}, {0.50588f, 0.14901f, 0.75294f} },
    { {0.965f, -0.818f}, {0.50588f, 0.14901f, 0.75294f} },
    { {0.895f, -0.818f}, {0.50588f, 0.14901f, 0.75294f} },

    ////colours 3
    { {0.625f, -0.79f}, {0.61568f, 0.68627f, 1.0f} },
    { {0.695f, -0.79f}, {0.61568f, 0.68627f, 1.0f} },
    { {0.695f, -0.73f}, {0.61568f, 0.68627f, 1.0f} },
    { {0.625f, -0.73f}, {0.61568f, 0.68627f, 1.0f} },

    { {0.715f, -0.79f}, {0.65482f, 0.77254f, 0.47843f} },
    { {0.785f, -0.79f}, {0.65482f, 0.77254f, 0.47843f} },
    { {0.785f, -0.73f}, {0.65482f, 0.77254f, 0.47843f} },
    { {0.715f, -0.73f}, {0.65482f, 0.77254f, 0.47843f} },

    { {0.805f, -0.79f}, {0.91372f, 0.870588f, 0.73333f} },
    { {0.875f, -0.79f}, {0.91372f, 0.870588f, 0.73333f} },
    { {0.875f, -0.73f}, {0.91372f, 0.870588f, 0.73333f} },
    { {0.805f, -0.73f}, {0.91372f, 0.870588f, 0.73333f} },

    { {0.895f, -0.79f}, {0.67843f, 0.137254f, 0.137254f} },
    { {0.965f, -0.79f}, {0.67843f, 0.137254f, 0.137254f} },
    { {0.965f, -0.73f}, {0.67843f, 0.137254f, 0.137254f} },
    { {0.895f, -0.73f}, {0.67843f, 0.137254f, 0.137254f} },

    ////colours 4
    { {0.625f, -0.70f}, {0.16078f, 0.81568f, 0.81568f} },
    { {0.695f, -0.70f}, {0.16078f, 0.81568f, 0.81568f} },
    { {0.695f, -0.638f}, {0.16078f, 0.81568f, 0.81568f} },
    { {0.625f, -0.638f}, {0.16078f, 0.81568f, 0.81568f} },

    { {0.715f, -0.70f}, {1.0f, 0.92156f, 0.2f} },
    { {0.785f, -0.70f}, {1.0f, 0.92156f, 0.2f} },
    { {0.785f, -0.638f}, {1.0f, 0.92156f, 0.2f} },
    { {0.715f, -0.638f}, {1.0f, 0.92156f, 0.2f} },

    { {0.805f, -0.70f}, {1.0f, 0.57254f, 0.2f} },
    { {0.875f, -0.70f}, {1.0f, 0.57254f, 0.2f} },
    { {0.875f, -0.638f}, {1.0f, 0.57254f, 0.2f} },
    { {0.805f, -0.638f}, {1.0f, 0.57254f, 0.2f} },

    { {0.895f, -0.70f}, {1.0f, 0.80392f, 0.95294f} },
    { {0.965f, -0.70f}, {1.0f, 0.80392f, 0.95294f} },
    { {0.965f, -0.638f}, {1.0f, 0.80392f, 0.95294f} },
    { {0.895f, -0.638f}, {1.0f, 0.80392f, 0.95294f} },

    // Brush Blocks
    // Triangle
    { {0.62f , -0.5f}, {0.0f, 0.0f, 0.0f} },
    { {0.73f, -0.5f},{0.0f, 0.0f, 0.0f} },
    { {0.73f, -0.3f}, {0.0f, 0.0f, 0.0f} },
    { {0.62f , -0.3f}, {0.0f, 0.0f, 0.0f} },
    // Square
    { {0.74f, -0.5f}, {0.0f, 0.0f, 0.0f} },
    { {0.85f, -0.5f},{0.0f, 0.0f, 0.0f} },
    { {0.85f, -0.3f}, {0.0f, 0.0f, 0.0f} },
    { {0.74f, -0.3f}, {0.0f, 0.0f, 0.0f} },
    // Circle
    { {0.86f, -0.5f}, {0.0f, 0.0f, 0.0f} },
    { {0.97f , -0.5f},{0.0f, 0.0f, 0.0f} },
    { {0.97f , -0.3f}, {0.0f, 0.0f, 0.0f} },
    { {0.86f, -0.3f}, {0.0f, 0.0f, 0.0f} },

    // Triangle White
    { {0.625f , -0.49f}, {1.0f, 1.0f, 1.0f} },
    { {0.725f, -0.49f},  {1.0f, 1.0f, 1.0f} },
    { {0.725f, -0.31f},  {1.0f, 1.0f, 1.0f} },
    { {0.625f , -0.31f}, {1.0f, 1.0f, 1.0f} },
    // Square White
    { {0.745f, -0.49f}, {1.0f, 1.0f, 1.0f} },
    { {0.845f, -0.49f}, {1.0f, 1.0f, 1.0f} },
    { {0.845f, -0.31f}, {1.0f, 1.0f, 1.0f} },
    { {0.745f, -0.31f}, {1.0f, 1.0f, 1.0f} },
    // Circle White
    { {0.865f, -0.49f},  {1.0f, 1.0f, 1.0f} },
    { {0.965f , -0.49f}, {1.0f, 1.0f, 1.0f} },
    { {0.965f , -0.31f}, {1.0f, 1.0f, 1.0f} },
    { {0.865f, -0.31f},  {1.0f, 1.0f, 1.0f} },

    // Triangle Icon
    { {0.63f, -0.32f}, {0.0f,0.0f,0.0f}},
    { {0.72f, -0.32f}, {0.0f,0.0f,0.0f} },
    { {0.675, -0.48f}, {0.0f, 0.0f, 0.0f}},
    // Square Icon
    { {0.75f, -0.48f}, {0.0f,0.0f,0.0f} },
    { {0.84f, -0.48f}, {0.0f,0.0f,0.0f} },
    { {0.84f, -0.32f}, {0.0f,0.0f,0.0f} },
    { {0.75f, -0.32f}, {0.0f,0.0f,0.0f} },
    // Circle/Octogon Icon
    { {0.87f, -0.40f}, {0.0f,0.0f,0.0f} },      //0
    { {0.88125f, -0.455f}, {0.0f,0.0f,0.0f} },//1
    { {0.915f, -0.48f}, {0.0f,0.0f,0.0f} },     //2
    { {0.94875f, -0.455f}, {0.0f,0.0f,0.0f} },//3
    { {0.96f, -0.40f}, {0.0f,0.0f,0.0f} },      //4
    { {0.88125f, -0.345f}, {0.0f,0.0f,0.0f} },//5
    { {0.915f,-0.32f}, {0.0f,0.0f,0.0f} },      //6
    { {0.94875f, -0.345f}, {0.0f,0.0f,0.0f} },//7

    // Brush Sizes
        // 1
    // 1
    { {0.62f , 0.0f}, {0.0f, 0.0f, 0.0f} },
    { {0.73f, 0.0f},{0.0f, 0.0f, 0.0f} },
    { {0.73f, 0.2f}, {0.0f, 0.0f, 0.0f} },
    { {0.62f , 0.2f}, {0.0f, 0.0f, 0.0f} },
    // 2
    { {0.74f, 0.0f}, {0.0f, 0.0f, 0.0f} },
    { {0.85f, 0.0f},{0.0f, 0.0f, 0.0f} },
    { {0.85f, 0.2f}, {0.0f, 0.0f, 0.0f} },
    { {0.74f, 0.2f}, {0.0f, 0.0f, 0.0f} },
    // 3
    { {0.86f , 0.0f}, {0.0f, 0.0f, 0.0f} },
    { {0.97f , 0.0f},{0.0f, 0.0f, 0.0f} },
    { {0.97f , 0.2f}, {0.0f, 0.0f, 0.0f} },
    { {0.86f , 0.2f}, {0.0f, 0.0f, 0.0f} },

    // 1 White
    { {0.625f , 0.01f}, {1.0f, 1.0f, 1.0f} },
    { {0.725f , 0.01f},  {1.0f, 1.0f, 1.0f} },
    { {0.725f , 0.19f},  {1.0f, 1.0f, 1.0f} },
    { {0.625f , 0.19f}, {1.0f, 1.0f, 1.0f} },
    // 2 White
    { {0.745f, 0.01f}, {1.0f, 1.0f, 1.0f} },
    { {0.845f, 0.01f}, {1.0f, 1.0f, 1.0f} },
    { {0.845f, 0.19f}, {1.0f, 1.0f, 1.0f} },
    { {0.745f, 0.19f}, {1.0f, 1.0f, 1.0f} },
    // 3 White
    { {0.865f , 0.01f},  {1.0f, 1.0f, 1.0f} },
    { {0.965f , 0.01f}, {1.0f, 1.0f, 1.0f} },
    { {0.965f , 0.19f}, {1.0f, 1.0f, 1.0f} },
    { {0.865f , 0.19f},  {1.0f, 1.0f, 1.0f} },
    // 4
    { {0.62f , 0.25f}, {0.0f, 0.0f, 0.0f} },
    { {0.73f , 0.25f},{0.0f, 0.0f, 0.0f} },
    { {0.73f , 0.45f}, {0.0f, 0.0f, 0.0f} },
    { {0.62f , 0.45f}, {0.0f, 0.0f, 0.0f} },
    // 5
    { {0.74f, 0.25f}, {0.0f, 0.0f, 0.0f} },
    { {0.85f, 0.25f},{0.0f, 0.0f, 0.0f} },
    { {0.85f, 0.45f}, {0.0f, 0.0f, 0.0f} },
    { {0.74f, 0.45f}, {0.0f, 0.0f, 0.0f} },
    // 6
    { {0.86f, 0.25f}, {0.0f, 0.0f, 0.0f} },
    { {0.97f, 0.25f},{0.0f, 0.0f, 0.0f} },
    { {0.97f, 0.45f}, {0.0f, 0.0f, 0.0f} },
    { {0.86f, 0.45f}, {0.0f, 0.0f, 0.0f} },
    // 4 White
    { {0.625f , 0.26f}, {1.0f, 1.0f, 1.0f} },
    { {0.725f , 0.26f},  {1.0f, 1.0f, 1.0f} },
    { {0.725f , 0.44f},  {1.0f, 1.0f, 1.0f} },
    { {0.625f , 0.44f}, {1.0f, 1.0f, 1.0f} },
    // 5 White
    { {0.745f, 0.26f}, {1.0f, 1.0f, 1.0f} },
    { {0.845f, 0.26f}, {1.0f, 1.0f, 1.0f} },
    { {0.845f, 0.44f}, {1.0f, 1.0f, 1.0f} },
    { {0.745f, 0.44f}, {1.0f, 1.0f, 1.0f} },
    // 6 White
    { {0.865f, 0.26f},  {0.0f, 0.0f, 0.0f} },
    { {0.965f, 0.26f},  {0.0f, 0.0f, 0.0f} },
    { {0.965f, 0.44f},  {0.0f, 0.0f, 0.0f} },
    { {0.865f, 0.44f},  {0.0f, 0.0f, 0.0f} },

    // Fill
    { {0.62f, 0.5f}, {0.0f,0.0f,0.0f} },
    { {0.97f, 0.5f}, {0.0f,0.0f,0.0f} },
    { {0.97f, 0.7f}, {0.0f,0.0f,0.0f} },
    { {0.62f, 0.7f}, {0.0f,0.0f,0.0f} },
    // fill white
    { {0.625f, 0.51f}, {1.0f,1.0f,1.0f} },
    { {0.965f, 0.51f}, {1.0f,1.0f,1.0f} },
    { {0.965f, 0.69f}, {1.0f,1.0f,1.0f} },
    { {0.625f, 0.69f}, {1.0f,1.0f,1.0f} },
    // I
    { {0.75f, 0.52f}, {0.0f,0.0f,0.0f} },
    { {0.76f, 0.52f}, {0.0f,0.0f,0.0f} },
    { {0.76f, 0.68f}, {0.0f,0.0f,0.0f} },
    { {0.75f, 0.68f}, {0.0f,0.0f,0.0f} },
    // L
    { {0.8f, 0.52f},  {0.0f,0.0f,0.0f} },
    { {0.81f, 0.52f}, {0.0f,0.0f,0.0f} },
    { {0.81f, 0.66f}, {0.0f,0.0f,0.0f} },
    { {0.8f, 0.68f},  {0.0f,0.0f,0.0f} },
    { {0.85f, 0.66f}, {0.0f,0.0f,0.0f} },
    { {0.85f, 0.68f},  {0.0f,0.0f,0.0f} },

    // L
    { {0.87f, 0.52f}, {0.0f,0.0f,0.0f} },
    { {0.88f, 0.52f}, {0.0f,0.0f,0.0f} },
    { {0.88f, 0.66f}, {0.0f,0.0f,0.0f} },
    { {0.87f, 0.68f}, {0.0f,0.0f,0.0f} },
    { {0.92f, 0.66f}, {0.0f,0.0f,0.0f} },
    { {0.92f, 0.68f},  {0.0f,0.0f,0.0f} },
    // F
    { {0.67f,0.52f}, {0.0f,0.0f,0.0f} }, //0
    { {0.72f,0.52f}, {0.0f,0.0f,0.0f} }, //1
    { {0.72f,0.54f}, {0.0f,0.0f,0.0f} }, //2
    { {0.68f,0.54f}, {0.0f,0.0f,0.0f} }, //3
    { {0.67f,0.68f}, {0.0f,0.0f,0.0f} }, //4
    { {0.68f,0.68f}, {0.0f,0.0f,0.0f} }, //5
    { {0.68f,0.58f}, {0.0f,0.0f,0.0f} }, //6
    { {0.72f,0.58f}, {0.0f,0.0f,0.0f} }, //7
    { {0.72f,0.60f}, {0.0f,0.0f,0.0f} }, //8
    { {0.68f,0.60f}, {0.0f,0.0f,0.0f} }, //9
    // width icons
    // 1 0.0260417 0.00925926
    { {0.67239f,0.09537f}, {0.0f,0.0f,0.0f} },
    { {0.677604f,0.09537f}, {0.0f,0.0f,0.0f} },
    { {0.677604f,0.10462f}, {0.0f,0.0f,0.0f} },
    { {0.67239f,0.10462f}, {0.0f,0.0f,0.0f} },
    // 2 0.028125 0.012963
    { {0.79135f,0.09351f}, {0.0f,0.0f,0.0f} },
    { {0.79862f,0.09351f}, {0.0f,0.0f,0.0f} },
    { {0.79862f,0.10648f}, {0.0f,0.0f,0.0f} },
    { {0.79135f,0.10648f}, {0.0f,0.0f,0.0f} },
    // 3 0.03125 0.0185185
    { {0.90979f,0.09074f}, {0.0f,0.0f,0.0f} },
    { {0.92020f,0.09074f}, {0.0f,0.0f,0.0f} },
    { {0.92020f,0.10925f}, {0.0f,0.0f,0.0f} },
    { {0.90979f,0.10925f}, {0.0f,0.0f,0.0f} },
    // 4 0.046875 0.0462963
    { {0.66197f,0.32685f}, {0.0f,0.0f,0.0f} },
    { {0.68802f,0.32685f}, {0.0f,0.0f,0.0f} },
    { {0.68802f,0.37314f}, {0.0f,0.0f,0.0f} },
    { {0.66197f,0.37314f}, {0.0f,0.0f,0.0f} },
    // 5 0.0729167 0.0925926
    { {0.76895f,0.30370f}, {0.0f,0.0f,0.0f} },
    { {0.82104f,0.30370f}, {0.0f,0.0f,0.0f} },
    { {0.82104f,0.39629f}, {0.0f,0.0f,0.0f} },
    { {0.76895f,0.39629f}, {0.0f,0.0f,0.0f} },



};

std::vector<Vertex> defaultVertices = {
    //canvas
    //1
    {{-1.0f, -1.0f}, {1.0f, 1.0f, 1.0f}},
    {{1.0f, -1.0f}, {1.0f, 1.0f, 1.0f}},
    {{1.0f, 1.0f}, {1.0f, 1.0f, 1.0f}},
    {{-1.0f, 1.0f}, {1.0f, 1.0f, 1.0f}},
    // uiblock
    //2
    {{0.6f, -1.0f}, {0.4f, 0.6f, 0.4f}},
    {{1.0f, -1.0f}, {0.4f, 0.6f, 0.4f}},
    {{1.0f, 1.0f}, {0.4f, 0.6f, 0.4f}},
    {{0.6f, 1.0f}, {0.4f, 0.6f, 0.4f}},
    // colourOutlines 1
    //3
    {{0.62f, -0.98f}, {0.0f, 0.0f, 0.0f}},
    {{0.7f, -0.98f},{0.0f, 0.0f, 0.0f}},
    {{0.7f, -0.9f}, {0.0f, 0.0f, 0.0f}},
    {{0.62f, -0.9f}, {0.0f, 0.0f, 0.0f}},
    //4
    {{0.71f, -0.98f}, {1.0f, 1.0f, 1.0f}},
    {{0.79f, -0.98f},{1.0f, 1.0f, 1.0f}},
    {{0.79f, -0.9f}, {1.0f, 1.0f, 1.0f}},
    {{0.71f, -0.9f}, {1.0f, 1.0f, 1.0f}},
    //5
    {{0.8f, -0.98f}, {0.0f, 0.0f, 0.0f}},
    {{0.88f, -0.98f},{0.0f, 0.0f, 0.0f}},
    {{0.88f, -0.9f}, {0.0f, 0.0f, 0.0f}},
    {{0.8f, -0.9f}, {0.0f, 0.0f, 0.0f}},
    //6
    {{0.89f, -0.98f}, {0.0f, 0.0f, 0.0f}},
    {{0.97f, -0.98f},{0.0f, 0.0f, 0.0f}},
    {{0.97f, -0.9f}, {0.0f, 0.0f, 0.0f}},
    {{0.89f, -0.9f}, {0.0f, 0.0f, 0.0f}},

    // colourOutlines 2
    //7
    {{0.62f, -0.89f}, {0.0f, 0.0f, 0.0f}},
    {{0.7f, -0.89f},{0.0f, 0.0f, 0.0f}},
    {{0.7f, -0.81f}, {0.0f, 0.0f, 0.0f}},
    {{0.62f, -0.81f}, {0.0f, 0.0f, 0.0f}},
    //8
    {{0.71f, -0.89f}, {0.0f, 0.0f, 0.0f}},
    {{0.79f, -0.89f},{0.0f, 0.0f, 0.0f}},
    {{0.79f, -0.81}, {0.0f, 0.0f, 0.0f}},
    {{0.71f, -0.81}, {0.0f, 0.0f, 0.0f}},
    //9
    {{0.8f, -0.89f}, {0.0f, 0.0f, 0.0f}},
    {{0.88f, -0.89f},{0.0f, 0.0f, 0.0f}},
    {{0.88f, -0.81f}, {0.0f, 0.0f, 0.0f}},
    {{0.8f, -0.81f}, {0.0f, 0.0f, 0.0f}},
    //10
    {{0.89f, -0.89f}, {0.0f, 0.0f, 0.0f}},
    {{0.97f, -0.89f},{0.0f, 0.0f, 0.0f}},
    {{0.97f, -0.81f}, {0.0f, 0.0f, 0.0f}},
    {{0.89f, -0.81f}, {0.0f, 0.0f, 0.0f}},

    // colourOutlines 3
    //11
    {{0.62f, -0.8f}, {0.0f, 0.0f, 0.0f}},
    {{0.7f, -0.8f},{0.0f, 0.0f, 0.0f}},
    {{0.7f, -0.72f}, {0.0f, 0.0f, 0.0f}},
    {{0.62f, -0.72f}, {0.0f, 0.0f, 0.0f}},
    //12
    {{0.71f, -0.8f}, {0.0f, 0.0f, 0.0f}},
    {{0.79f, -0.8f},{0.0f, 0.0f, 0.0f}},
    {{0.79f, -0.72f}, {0.0f, 0.0f, 0.0f}},
    {{0.71f, -0.72f}, {0.0f, 0.0f, 0.0f}},
    //13
    {{0.8f, -0.8f}, {0.0f, 0.0f, 0.0f}},
    {{0.88f, -0.8f},{0.0f, 0.0f, 0.0f}},
    {{0.88f, -0.72f}, {0.0f, 0.0f, 0.0f}},
    {{0.8f, -0.72f}, {0.0f, 0.0f, 0.0f}},
    //14
    {{0.89f, -0.8f}, {0.0f, 0.0f, 0.0f}},
    {{0.97f, -0.8f},{0.0f, 0.0f, 0.0f}},
    {{0.97f, -0.72f}, {0.0f, 0.0f, 0.0f}},
    {{0.89f, -0.72f}, {0.0f, 0.0f, 0.0f}},

    // colourOutlines 4
    //15
    {{0.62f, -0.71f}, {0.0f, 0.0f, 0.0f}},
    {{0.7f, -0.71f},{0.0f, 0.0f, 0.0f}},
    {{0.7f, -0.63f}, {0.0f, 0.0f, 0.0f}},
    {{0.62f, -0.63f}, {0.0f, 0.0f, 0.0f}},
    //16
    {{0.71f, -0.71f}, {0.0f, 0.0f, 0.0f}},
    {{0.79f, -0.71f},{0.0f, 0.0f, 0.0f}},
    {{0.79f, -0.63f}, {0.0f, 0.0f, 0.0f}},
    {{0.71f, -0.63f}, {0.0f, 0.0f, 0.0f}},
    //17
    {{0.8f, -0.71f}, {0.0f, 0.0f, 0.0f}},
    {{0.88f, -0.71f},{0.0f, 0.0f, 0.0f}},
    {{0.88f, -0.63f}, {0.0f, 0.0f, 0.0f}},
    {{0.8f, -0.63f}, {0.0f, 0.0f, 0.0f}},
    //18
    {{0.89f, -0.71f}, {0.0f, 0.0f, 0.0f}},
    {{0.97f, -0.71f},{0.0f, 0.0f, 0.0f}},
    {{0.97f, -0.63f}, {0.0f, 0.0f, 0.0f}},
    {{0.89f, -0.63f}, {0.0f, 0.0f, 0.0f}},

    ////colours 1
    {{0.625f, -0.97f}, {1.0f, 1.0f, 1.0f}},
    {{0.695f, -0.97f},{1.0f, 1.0f, 1.0f}},
    {{0.695f, -0.91f}, {1.0f, 1.0f, 1.0f}},
    {{0.625f, -0.91f}, {1.0f, 1.0f, 1.0f}},

    {{0.715f, -0.97f}, {0.0f, 0.0f, 0.0f}},
    {{0.785f, -0.97f},{0.0f, 0.0f, 0.0f}},
    {{0.785f, -0.91f}, {0.0f, 0.0f, 0.0f}},
    {{0.715f, -0.91f}, {0.0f, 0.0f, 0.0f}},

    {{0.805f, -0.97f}, {0.6274f, 0.6274f, 0.6274f}},
    {{0.875f, -0.97f}, {0.6274f, 0.6274f, 0.6274f} },
    { {0.875f, -0.91f}, {0.6274f, 0.6274f, 0.6274f} },
    { {0.805f, -0.91f}, {0.6274f, 0.6274f, 0.6274f}},

    {{0.895f, -0.97f}, {0.34117f, 0.34117f, 0.34117f}},
    {{0.965f, -0.97f}, {0.34117f, 0.34117f, 0.34117f} },
    { {0.965f, -0.91f}, {0.34117f, 0.34117f, 0.34117f} },
    { {0.895f, -0.91f}, {0.34117f, 0.34117f, 0.34117f}},

    ////colours 2
    { {0.625f, -0.882f}, {0.1647f, 0.29411f, 0.84313} },
    { {0.695f, -0.882f}, {0.1647f, 0.29411f, 0.84313} },
    { {0.695f, -0.818f}, {0.1647f, 0.29411f, 0.84313} },
    { {0.625f, -0.818f}, {0.1647f, 0.29411f, 0.84313} },

    { {0.715f, -0.882f}, {0.11372f, 0.41176f, 0.07843f} },
    { {0.785f, -0.882f}, {0.11372f, 0.41176f, 0.07843f} },
    { {0.785f, -0.818f}, {0.11372f, 0.41176f, 0.07843f} },
    { {0.715f, -0.818f}, {0.11372f, 0.41176f, 0.07843f} },

    { {0.805f, -0.882f}, {0.50588f, 0.29019f, 0.09803f} },
    { {0.875f, -0.882f}, {0.50588f, 0.29019f, 0.09803f} },
    { {0.875f, -0.818f}, {0.50588f, 0.29019f, 0.09803f} },
    { {0.805f, -0.818f}, {0.50588f, 0.29019f, 0.09803f} },

    { {0.895f, -0.882f}, {0.50588f, 0.14901f, 0.75294f} },
    { {0.965f, -0.882f}, {0.50588f, 0.14901f, 0.75294f} },
    { {0.965f, -0.818f}, {0.50588f, 0.14901f, 0.75294f} },
    { {0.895f, -0.818f}, {0.50588f, 0.14901f, 0.75294f} },

    ////colours 3
    { {0.625f, -0.79f}, {0.61568f, 0.68627f, 1.0f} },
    { {0.695f, -0.79f}, {0.61568f, 0.68627f, 1.0f} },
    { {0.695f, -0.73f}, {0.61568f, 0.68627f, 1.0f} },
    { {0.625f, -0.73f}, {0.61568f, 0.68627f, 1.0f} },

    { {0.715f, -0.79f}, {0.65482f, 0.77254f, 0.47843f} },
    { {0.785f, -0.79f}, {0.65482f, 0.77254f, 0.47843f} },
    { {0.785f, -0.73f}, {0.65482f, 0.77254f, 0.47843f} },
    { {0.715f, -0.73f}, {0.65482f, 0.77254f, 0.47843f} },

    { {0.805f, -0.79f}, {0.91372f, 0.870588f, 0.73333f} },
    { {0.875f, -0.79f}, {0.91372f, 0.870588f, 0.73333f} },
    { {0.875f, -0.73f}, {0.91372f, 0.870588f, 0.73333f} },
    { {0.805f, -0.73f}, {0.91372f, 0.870588f, 0.73333f} },

    { {0.895f, -0.79f}, {0.67843f, 0.137254f, 0.137254f} },
    { {0.965f, -0.79f}, {0.67843f, 0.137254f, 0.137254f} },
    { {0.965f, -0.73f}, {0.67843f, 0.137254f, 0.137254f} },
    { {0.895f, -0.73f}, {0.67843f, 0.137254f, 0.137254f} },

    ////colours 4
    { {0.625f, -0.70f}, {0.16078f, 0.81568f, 0.81568f} },
    { {0.695f, -0.70f}, {0.16078f, 0.81568f, 0.81568f} },
    { {0.695f, -0.638f}, {0.16078f, 0.81568f, 0.81568f} },
    { {0.625f, -0.638f}, {0.16078f, 0.81568f, 0.81568f} },

    { {0.715f, -0.70f}, {1.0f, 0.92156f, 0.2f} },
    { {0.785f, -0.70f}, {1.0f, 0.92156f, 0.2f} },
    { {0.785f, -0.638f}, {1.0f, 0.92156f, 0.2f} },
    { {0.715f, -0.638f}, {1.0f, 0.92156f, 0.2f} },

    { {0.805f, -0.70f}, {1.0f, 0.57254f, 0.2f} },
    { {0.875f, -0.70f}, {1.0f, 0.57254f, 0.2f} },
    { {0.875f, -0.638f}, {1.0f, 0.57254f, 0.2f} },
    { {0.805f, -0.638f}, {1.0f, 0.57254f, 0.2f} },

    { {0.895f, -0.70f}, {1.0f, 0.80392f, 0.95294f} },
    { {0.965f, -0.70f}, {1.0f, 0.80392f, 0.95294f} },
    { {0.965f, -0.638f}, {1.0f, 0.80392f, 0.95294f} },
    { {0.895f, -0.638f}, {1.0f, 0.80392f, 0.95294f} },

    // Brush Blocks
    // Triangle
    { {0.62f , -0.5f}, {0.0f, 0.0f, 0.0f} },
    { {0.73f, -0.5f},{0.0f, 0.0f, 0.0f} },
    { {0.73f, -0.3f}, {0.0f, 0.0f, 0.0f} },
    { {0.62f , -0.3f}, {0.0f, 0.0f, 0.0f} },
    // Square
    { {0.74f, -0.5f}, {0.0f, 0.0f, 0.0f} },
    { {0.85f, -0.5f},{0.0f, 0.0f, 0.0f} },
    { {0.85f, -0.3f}, {0.0f, 0.0f, 0.0f} },
    { {0.74f, -0.3f}, {0.0f, 0.0f, 0.0f} },
    // Circle
    { {0.86f, -0.5f}, {0.0f, 0.0f, 0.0f} },
    { {0.97f , -0.5f},{0.0f, 0.0f, 0.0f} },
    { {0.97f , -0.3f}, {0.0f, 0.0f, 0.0f} },
    { {0.86f, -0.3f}, {0.0f, 0.0f, 0.0f} },

    // Triangle White
    { {0.625f , -0.49f}, {1.0f, 1.0f, 1.0f} },
    { {0.725f, -0.49f},  {1.0f, 1.0f, 1.0f} },
    { {0.725f, -0.31f},  {1.0f, 1.0f, 1.0f} },
    { {0.625f , -0.31f}, {1.0f, 1.0f, 1.0f} },
    // Square White
    { {0.745f, -0.49f}, {1.0f, 1.0f, 1.0f} },
    { {0.845f, -0.49f}, {1.0f, 1.0f, 1.0f} },
    { {0.845f, -0.31f}, {1.0f, 1.0f, 1.0f} },
    { {0.745f, -0.31f}, {1.0f, 1.0f, 1.0f} },
    // Circle White
    { {0.865f, -0.49f},  {1.0f, 1.0f, 1.0f} },
    { {0.965f , -0.49f}, {1.0f, 1.0f, 1.0f} },
    { {0.965f , -0.31f}, {1.0f, 1.0f, 1.0f} },
    { {0.865f, -0.31f},  {1.0f, 1.0f, 1.0f} },

    // Triangle Icon
    { {0.63f, -0.32f}, {0.0f,0.0f,0.0f}},
    { {0.72f, -0.32f}, {0.0f,0.0f,0.0f} },
    { {0.675, -0.48f}, {0.0f, 0.0f, 0.0f}},
    // Square Icon
    { {0.75f, -0.48f}, {0.0f,0.0f,0.0f} },
    { {0.84f, -0.48f}, {0.0f,0.0f,0.0f} },
    { {0.84f, -0.32f}, {0.0f,0.0f,0.0f} },
    { {0.75f, -0.32f}, {0.0f,0.0f,0.0f} },
    // Circle/Octogon Icon
    { {0.87f, -0.40f}, {0.0f,0.0f,0.0f} },      //0
    { {0.88125f, -0.455f}, {0.0f,0.0f,0.0f} },//1
    { {0.915f, -0.48f}, {0.0f,0.0f,0.0f} },     //2
    { {0.94875f, -0.455f}, {0.0f,0.0f,0.0f} },//3
    { {0.96f, -0.40f}, {0.0f,0.0f,0.0f} },      //4
    { {0.88125f, -0.345f}, {0.0f,0.0f,0.0f} },//5
    { {0.915f,-0.32f}, {0.0f,0.0f,0.0f} },      //6
    { {0.94875f, -0.345f}, {0.0f,0.0f,0.0f} },//7

    // Brush Sizes
        // 1
    // 1
    { {0.62f , 0.0f}, {0.0f, 0.0f, 0.0f} },
    { {0.73f, 0.0f},{0.0f, 0.0f, 0.0f} },
    { {0.73f, 0.2f}, {0.0f, 0.0f, 0.0f} },
    { {0.62f , 0.2f}, {0.0f, 0.0f, 0.0f} },
    // 2
    { {0.74f, 0.0f}, {0.0f, 0.0f, 0.0f} },
    { {0.85f, 0.0f},{0.0f, 0.0f, 0.0f} },
    { {0.85f, 0.2f}, {0.0f, 0.0f, 0.0f} },
    { {0.74f, 0.2f}, {0.0f, 0.0f, 0.0f} },
    // 3
    { {0.86f , 0.0f}, {0.0f, 0.0f, 0.0f} },
    { {0.97f , 0.0f},{0.0f, 0.0f, 0.0f} },
    { {0.97f , 0.2f}, {0.0f, 0.0f, 0.0f} },
    { {0.86f , 0.2f}, {0.0f, 0.0f, 0.0f} },

    // 1 White
    { {0.625f , 0.01f}, {1.0f, 1.0f, 1.0f} },
    { {0.725f , 0.01f},  {1.0f, 1.0f, 1.0f} },
    { {0.725f , 0.19f},  {1.0f, 1.0f, 1.0f} },
    { {0.625f , 0.19f}, {1.0f, 1.0f, 1.0f} },
    // 2 White
    { {0.745f, 0.01f}, {1.0f, 1.0f, 1.0f} },
    { {0.845f, 0.01f}, {1.0f, 1.0f, 1.0f} },
    { {0.845f, 0.19f}, {1.0f, 1.0f, 1.0f} },
    { {0.745f, 0.19f}, {1.0f, 1.0f, 1.0f} },
    // 3 White
    { {0.865f , 0.01f},  {1.0f, 1.0f, 1.0f} },
    { {0.965f , 0.01f}, {1.0f, 1.0f, 1.0f} },
    { {0.965f , 0.19f}, {1.0f, 1.0f, 1.0f} },
    { {0.865f , 0.19f},  {1.0f, 1.0f, 1.0f} },
    // 4
    { {0.62f , 0.25f}, {0.0f, 0.0f, 0.0f} },
    { {0.73f , 0.25f},{0.0f, 0.0f, 0.0f} },
    { {0.73f , 0.45f}, {0.0f, 0.0f, 0.0f} },
    { {0.62f , 0.45f}, {0.0f, 0.0f, 0.0f} },
    // 5
    { {0.74f, 0.25f}, {0.0f, 0.0f, 0.0f} },
    { {0.85f, 0.25f},{0.0f, 0.0f, 0.0f} },
    { {0.85f, 0.45f}, {0.0f, 0.0f, 0.0f} },
    { {0.74f, 0.45f}, {0.0f, 0.0f, 0.0f} },
    // 6
    { {0.86f, 0.25f}, {0.0f, 0.0f, 0.0f} },
    { {0.97f, 0.25f},{0.0f, 0.0f, 0.0f} },
    { {0.97f, 0.45f}, {0.0f, 0.0f, 0.0f} },
    { {0.86f, 0.45f}, {0.0f, 0.0f, 0.0f} },
    // 4 White
    { {0.625f , 0.26f}, {1.0f, 1.0f, 1.0f} },
    { {0.725f , 0.26f},  {1.0f, 1.0f, 1.0f} },
    { {0.725f , 0.44f},  {1.0f, 1.0f, 1.0f} },
    { {0.625f , 0.44f}, {1.0f, 1.0f, 1.0f} },
    // 5 White
    { {0.745f, 0.26f}, {1.0f, 1.0f, 1.0f} },
    { {0.845f, 0.26f}, {1.0f, 1.0f, 1.0f} },
    { {0.845f, 0.44f}, {1.0f, 1.0f, 1.0f} },
    { {0.745f, 0.44f}, {1.0f, 1.0f, 1.0f} },
    // 6 White
    { {0.865f, 0.26f},  {0.0f, 0.0f, 0.0f} },
    { {0.965f, 0.26f},  {0.0f, 0.0f, 0.0f} },
    { {0.965f, 0.44f},  {0.0f, 0.0f, 0.0f} },
    { {0.865f, 0.44f},  {0.0f, 0.0f, 0.0f} },

    // Fill
    { {0.62f, 0.5f}, {0.0f,0.0f,0.0f} },
    { {0.97f, 0.5f}, {0.0f,0.0f,0.0f} },
    { {0.97f, 0.7f}, {0.0f,0.0f,0.0f} },
    { {0.62f, 0.7f}, {0.0f,0.0f,0.0f} },
    // fill white
    { {0.625f, 0.51f}, {1.0f,1.0f,1.0f} },
    { {0.965f, 0.51f}, {1.0f,1.0f,1.0f} },
    { {0.965f, 0.69f}, {1.0f,1.0f,1.0f} },
    { {0.625f, 0.69f}, {1.0f,1.0f,1.0f} },
    // I
    { {0.75f, 0.52f}, {0.0f,0.0f,0.0f} },
    { {0.76f, 0.52f}, {0.0f,0.0f,0.0f} },
    { {0.76f, 0.68f}, {0.0f,0.0f,0.0f} },
    { {0.75f, 0.68f}, {0.0f,0.0f,0.0f} },
    // L
    { {0.8f, 0.52f},  {0.0f,0.0f,0.0f} },
    { {0.81f, 0.52f}, {0.0f,0.0f,0.0f} },
    { {0.81f, 0.66f}, {0.0f,0.0f,0.0f} },
    { {0.8f, 0.68f},  {0.0f,0.0f,0.0f} },
    { {0.85f, 0.66f}, {0.0f,0.0f,0.0f} },
    { {0.85f, 0.68f},  {0.0f,0.0f,0.0f} },

    // L
    { {0.87f, 0.52f}, {0.0f,0.0f,0.0f} },
    { {0.88f, 0.52f}, {0.0f,0.0f,0.0f} },
    { {0.88f, 0.66f}, {0.0f,0.0f,0.0f} },
    { {0.87f, 0.68f}, {0.0f,0.0f,0.0f} },
    { {0.92f, 0.66f}, {0.0f,0.0f,0.0f} },
    { {0.92f, 0.68f},  {0.0f,0.0f,0.0f} },
    // F
    { {0.67f,0.52f}, {0.0f,0.0f,0.0f} }, //0
    { {0.72f,0.52f}, {0.0f,0.0f,0.0f} }, //1
    { {0.72f,0.54f}, {0.0f,0.0f,0.0f} }, //2
    { {0.68f,0.54f}, {0.0f,0.0f,0.0f} }, //3
    { {0.67f,0.68f}, {0.0f,0.0f,0.0f} }, //4
    { {0.68f,0.68f}, {0.0f,0.0f,0.0f} }, //5
    { {0.68f,0.58f}, {0.0f,0.0f,0.0f} }, //6
    { {0.72f,0.58f}, {0.0f,0.0f,0.0f} }, //7
    { {0.72f,0.60f}, {0.0f,0.0f,0.0f} }, //8
    { {0.68f,0.60f}, {0.0f,0.0f,0.0f} }, //9
    // width icons
    // 1 0.0260417 0.00925926
    { {0.67239f,0.09537f}, {0.0f,0.0f,0.0f} },
    { {0.677604f,0.09537f}, {0.0f,0.0f,0.0f} },
    { {0.677604f,0.10462f}, {0.0f,0.0f,0.0f} },
    { {0.67239f,0.10462f}, {0.0f,0.0f,0.0f} },
    // 2 0.028125 0.012963
    { {0.79135f,0.09351f}, {0.0f,0.0f,0.0f} },
    { {0.79862f,0.09351f}, {0.0f,0.0f,0.0f} },
    { {0.79862f,0.10648f}, {0.0f,0.0f,0.0f} },
    { {0.79135f,0.10648f}, {0.0f,0.0f,0.0f} },
    // 3 0.03125 0.0185185
    { {0.90979f,0.09074f}, {0.0f,0.0f,0.0f} },
    { {0.92020f,0.09074f}, {0.0f,0.0f,0.0f} },
    { {0.92020f,0.10925f}, {0.0f,0.0f,0.0f} },
    { {0.90979f,0.10925f}, {0.0f,0.0f,0.0f} },
    // 4 0.046875 0.0462963
    { {0.66197f,0.32685f}, {0.0f,0.0f,0.0f} },
    { {0.68802f,0.32685f}, {0.0f,0.0f,0.0f} },
    { {0.68802f,0.37314f}, {0.0f,0.0f,0.0f} },
    { {0.66197f,0.37314f}, {0.0f,0.0f,0.0f} },
    // 5 0.0729167 0.0925926
    { {0.76895f,0.30370f}, {0.0f,0.0f,0.0f} },
    { {0.82104f,0.30370f}, {0.0f,0.0f,0.0f} },
    { {0.82104f,0.39629f}, {0.0f,0.0f,0.0f} },
    { {0.76895f,0.39629f}, {0.0f,0.0f,0.0f} },



};

std::vector<uint32_t> indices = {
    0, 1, 2, 2, 3, 0,


    4, 5,6, 6,7,4,

    8,9,10,10,11,8,

    12,13,14,14,15,12,

    16,17,18,18,19,16,

    20, 21, 22, 22, 23, 20,
    24, 25, 26, 26, 27, 24,
    28, 29, 30, 30, 31, 28,
    32, 33, 34, 34, 35, 32,
    36, 37, 38, 38, 39, 36,
    40, 41, 42, 42, 43, 40,
    44, 45, 46, 46, 47, 44,
    48, 49, 50, 50, 51, 48,
    52, 53, 54, 54, 55, 52,
    56, 57, 58, 58, 59, 56,
    60, 61, 62, 62, 63, 60,
    64, 65, 66, 66, 67, 64,
    68, 69, 70, 70, 71, 68,
    72, 73, 74, 74, 75, 72,
    76, 77, 78, 78, 79, 76,
    80, 81, 82, 82, 83, 80,
    84, 85, 86, 86, 87, 84,
    88, 89, 90, 90, 91, 88,
    92, 93, 94, 94, 95, 92,
    96, 97, 98, 98, 99, 96,
    100, 101, 102, 102, 103, 100,
    104, 105, 106, 106, 107, 104,
    108, 109, 110, 110, 111, 108,
    112, 113, 114, 114, 115, 112,
    116, 117, 118, 118, 119, 116,
    120, 121, 122, 122, 123, 120,
    124, 125, 126, 126, 127, 124,
    128, 129, 130, 130, 131, 128,
    132, 133, 134, 134, 135, 132,
    136, 137, 138, 138, 139, 136,
    140, 141, 142, 142 ,143, 140,
    144, 145, 146, 146, 147, 144,
    148, 149, 150, 150, 151, 148,
    152, 153, 154, 154, 155, 152,
    156, 157, 158, 158, 159, 156,

    160,162,161,

    163, 164, 165, 165, 166,163,

    167,168,169,167,169,170,167,170,171,167,171,172,171,173,172,171,174,173,
    // brush widths 1
    175,176,177,177,178,175,
    179,180,181,181,182,179,
    183,184,185,185,186,183,
    187,188,189,189,190,187,
    191,192,193,193,194,191,
    195,196,197,197,198,195,
    // brush widths 2
    199,200,201,201,202,199,
    203,204,205,205,206,203,
    207,208,209,209,210,207,
    211,212,213,213,214,211,
    215,216,217,217,218,215,
    219,220,221,221,222,219,

    //fill
    223,224,225,225,226,223,
    227,228,229,229,230,227,
    //I
    231,232,233,233,234,231,
    //L
    235,236,237,237,238,235,
    237,239,240,240,238,237,
    //L
    241,242,243,243,244,241,
    243,245,246,246,244,243,
    //F
    247,248,249,249,250,247,
    247,250,252,252,251,247,
    253,254,255,255,256,253,

    257,258,259,259,260,257,
    261,262,263,263,264,261,
    265,266,267,267,268,265,
    269,270,271,271,272,269,
    273,274,275,275,276,273



};

std::vector<uint32_t> defaultIndices = {
    0, 1, 2, 2, 3, 0,


    4, 5,6, 6,7,4,

    8,9,10,10,11,8,

    12,13,14,14,15,12,

    16,17,18,18,19,16,

    20, 21, 22, 22, 23, 20,
    24, 25, 26, 26, 27, 24,
    28, 29, 30, 30, 31, 28,
    32, 33, 34, 34, 35, 32,
    36, 37, 38, 38, 39, 36,
    40, 41, 42, 42, 43, 40,
    44, 45, 46, 46, 47, 44,
    48, 49, 50, 50, 51, 48,
    52, 53, 54, 54, 55, 52,
    56, 57, 58, 58, 59, 56,
    60, 61, 62, 62, 63, 60,
    64, 65, 66, 66, 67, 64,
    68, 69, 70, 70, 71, 68,
    72, 73, 74, 74, 75, 72,
    76, 77, 78, 78, 79, 76,
    80, 81, 82, 82, 83, 80,
    84, 85, 86, 86, 87, 84,
    88, 89, 90, 90, 91, 88,
    92, 93, 94, 94, 95, 92,
    96, 97, 98, 98, 99, 96,
    100, 101, 102, 102, 103, 100,
    104, 105, 106, 106, 107, 104,
    108, 109, 110, 110, 111, 108,
    112, 113, 114, 114, 115, 112,
    116, 117, 118, 118, 119, 116,
    120, 121, 122, 122, 123, 120,
    124, 125, 126, 126, 127, 124,
    128, 129, 130, 130, 131, 128,
    132, 133, 134, 134, 135, 132,
    136, 137, 138, 138, 139, 136,
    140, 141, 142, 142 ,143, 140,
    144, 145, 146, 146, 147, 144,
    148, 149, 150, 150, 151, 148,
    152, 153, 154, 154, 155, 152,
    156, 157, 158, 158, 159, 156,

    160,162,161,

    163, 164, 165, 165, 166,163,

    167,168,169,167,169,170,167,170,171,167,171,172,171,173,172,171,174,173,
    // brush widths 1
    175,176,177,177,178,175,
    179,180,181,181,182,179,
    183,184,185,185,186,183,
    187,188,189,189,190,187,
    191,192,193,193,194,191,
    195,196,197,197,198,195,
    // brush widths 2
    199,200,201,201,202,199,
    203,204,205,205,206,203,
    207,208,209,209,210,207,
    211,212,213,213,214,211,
    215,216,217,217,218,215,
    219,220,221,221,222,219,

    //fill
    223,224,225,225,226,223,
    227,228,229,229,230,227,
    //I
    231,232,233,233,234,231,
    //L
    235,236,237,237,238,235,
    237,239,240,240,238,237,
    //L
    241,242,243,243,244,241,
    243,245,246,246,244,243,
    //F
    247,248,249,249,250,247,
    247,250,252,252,251,247,
    253,254,255,255,256,253,

    257,258,259,259,260,257,
    261,262,263,263,264,261,
    265,266,267,267,268,265,
    269,270,271,271,272,269,
    273,274,275,275,276,273



};



DrawnObject canvas{
    "Canvas",

    {{{-1.0f, -1.0f}, {1.0f, 1.0f, 1.0f}},
    {{1.0f, -1.0f}, {1.0f, 1.0f, 1.0f}},
    {{1.0f, 1.0f}, {1.0f, 1.0f, 1.0f}},
    {{-1.0f, 1.0f}, {1.0f, 1.0f, 1.0f}}},

    {0,1,2,2,3,0}
};

DrawnObject uiBlock{
    "Ui Block",

    {   {{0.6f, -1.0f}, {0.8f, 1.0f, 0.8f}},
    {{0.6f, 1.0f}, {0.8f, 1.0f, 0.8f}},
    {{1.0f, 1.0f}, {0.8f, 1.0f, 0.8f}},
    {{1.0f, -1.0f}, {0.8f, 1.0f, 0.8f}} },

    {0,1,2,2,3,0}
};

struct ObjectList {
    std::vector<DrawnObject> objectList;

    void addToList(DrawnObject object) {
        objectList.push_back(object);
    };
};



class HelloTriangleApplication {
public:
    void run() {
        initWindow();
        initVulkan();
        initObjects();
        mainLoop();
        cleanup();
        exit(0);
    }

private:
    GLFWwindow* window;

    VkInstance instance;
    VkDebugUtilsMessengerEXT debugMessenger;
    VkSurfaceKHR surface;

    VkPhysicalDevice physicalDevice = VK_NULL_HANDLE;
    VkDevice device;

    VkQueue graphicsQueue;
    VkQueue presentQueue;

    VkSwapchainKHR swapChain;
    std::vector<VkImage> swapChainImages;
    VkFormat swapChainImageFormat;
    VkExtent2D swapChainExtent;
    std::vector<VkImageView> swapChainImageViews;
    std::vector<VkFramebuffer> swapChainFramebuffers;

    VkRenderPass renderPass;
    VkPipelineLayout pipelineLayout;
    VkPipeline graphicsPipeline;
    VkPipeline graphicsPipeline2;

    VkCommandPool commandPool;

    VkBuffer vertexBuffer;
    VkDeviceMemory vertexBufferMemory;
    VkBuffer indexBuffer;
    VkDeviceMemory indexBufferMemory;

    std::vector<VkCommandBuffer> commandBuffers;

    std::vector<VkSemaphore> imageAvailableSemaphores;
    std::vector<VkSemaphore> renderFinishedSemaphores;
    std::vector<VkFence> inFlightFences;
    uint32_t currentFrame = 0;

    ObjectList objectList;
    std::string selectedBrush = "Square";
    int brushWidth = 20;
    int width, height;
    glm::vec3 selectedColour = { 0.6f,0.6f,0.6f };

    bool framebufferResized = false;

    void initWindow() {
        glfwInit();

        glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);

        window = glfwCreateWindow(WIDTH, HEIGHT, "Drawing Program", nullptr, nullptr);
        glfwSetWindowUserPointer(window, this);
        glfwSetFramebufferSizeCallback(window, framebufferResizeCallback);
    }

    static void framebufferResizeCallback(GLFWwindow* window, int width, int height) {
        auto app = reinterpret_cast<HelloTriangleApplication*>(glfwGetWindowUserPointer(window));
        app->framebufferResized = true;
    }

    void initVulkan() {
        createInstance();
        //setupDebugMessenger();
        createSurface();
        pickPhysicalDevice();
        createLogicalDevice();
        createSwapChain();
        createImageViews();
        createRenderPass();
        createGraphicsPipeline();
        createFramebuffers();
        createCommandPool();
        createVertexBuffer(vertices);
        createIndexBuffer(indices);
        createCommandBuffers();
        createSyncObjects();
    }

    void initObjects() {
        objectList.addToList(canvas);
        objectList.addToList(uiBlock);
    }

    void mainLoop() {
        while (!glfwWindowShouldClose(window)) {
            glfwPollEvents();
            int state = glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_LEFT);
            if (state == GLFW_PRESS) {
                clickCheck(window, state);
            }
            drawFrame();

        }


        vkDeviceWaitIdle(device);
    }

    void clickCheck(GLFWwindow* window, int action) {
       
        
        if (action == GLFW_PRESS) {
            double x, y;
            glfwGetCursorPos(window, &x, &y);
            glfwGetWindowSize(window, &width, &height);
            if (x < width * 0.8) {

                

             

                if (selectedBrush == "Square") {
                    squareBrushHandler(x,y);
                }

                if (selectedBrush == "Triangle") {
                    triangleBrushHandler(x, y);
                }

                if (selectedBrush == "Circle") {
                    circleBrushHandler(x, y);
                }
                //std::cout << indices.size();
                //std::cout << "\n";
                //std::cout << normalize(brushWidth+980, width, true)<< " ";
                //std::cout << normalize(brushWidth+ 540, height, true) << "\n";
                VkBuffer temp1 = vertexBuffer;
                VkBuffer temp2 = indexBuffer;
                VkDeviceMemory temp3 = vertexBufferMemory;
                VkDeviceMemory temp4 = indexBufferMemory;
                createVertexBuffer(vertices);
                vkDestroyBuffer(device,temp1,nullptr);
                vkFreeMemory(device, temp3, nullptr);
                createIndexBuffer(indices);
                vkDestroyBuffer(device, temp2, nullptr);
                vkFreeMemory(device, temp4, nullptr);
                
            }
            else {
                float normalX = normalize2(x, width);
                float normalY = normalize2(y, height);
                //std::cout << normalX << " " << normalY << "\n";
                //    ////colours 1
                //{ { 0.625f, -0.97f }, { 1.0f, 1.0f, 1.0f } },
                //{ {0.695f, -0.91f}, {1.0f, 1.0f, 1.0f} },

                //{ {0.715f, -0.97f}, {0.0f, 0.0f, 0.0f} }
                //{ {0.785f, -0.91f}, {0.0f, 0.0f, 0.0f} },


                // 1
                if (normalY < -0.9f && normalY > -0.98f) {
                    if (normalX > 0.62f && normalX < 0.7f) {
                        selectedColour = { 1.0f, 1.0f, 1.0f };
                    }
                    else if (normalX > 0.71f && normalX < 0.79f) {
                        selectedColour = { 0.0f, 0.0f, 0.0f };
                    }
                    else if (normalX > 0.8f && normalX < 0.88f) {
                        selectedColour = { 0.6274f, 0.6274f, 0.6274f };
                    }
                    else if (normalX > 0.89f && normalX < 0.97f) {
                        selectedColour = { 0.34117f, 0.34117f, 0.34117f };
                    }
                } // 2
                else if (normalY < -0.81f && normalY > -0.89f) {
                    if (normalX > 0.62f && normalX < 0.7f) {
                        selectedColour = { 0.1647f, 0.29411f, 0.84313 };
                    }
                    else if (normalX > 0.71f && normalX < 0.79f) {
                        selectedColour = { 0.11372f, 0.41176f, 0.07843f };
                    }
                    else if (normalX > 0.8f && normalX < 0.88f) {
                        selectedColour = { 0.50588f, 0.29019f, 0.09803f };
                    }
                    else if (normalX > 0.89f && normalX < 0.97f) {
                        selectedColour = { 0.50588f, 0.14901f, 0.75294f };
                    }
                } // 3
                else if (normalY < -0.72f && normalY > -0.8f) {
                    if (normalX > 0.62f && normalX < 0.7f) {
                        selectedColour = { 0.61568f, 0.68627f, 1.0f };
                    }
                    else if (normalX > 0.71f && normalX < 0.79f) {
                        selectedColour = { 0.65482f, 0.77254f, 0.47843f };
                    }
                    else if (normalX > 0.8f && normalX < 0.88f) {
                        selectedColour = { 0.91372f, 0.870588f, 0.73333f };
                    }
                    else if (normalX > 0.89f && normalX < 0.97f) {
                        selectedColour = { 0.67843f, 0.137254f, 0.137254f };
                    }
                } // 4
                else if (normalY < -0.63f && normalY > -0.71f) {
                    if (normalX > 0.62f && normalX < 0.7f) {
                        selectedColour = { 0.16078f, 0.81568f, 0.81568f };
                    }
                    else if (normalX > 0.71f && normalX < 0.79f) {
                        selectedColour = { 1.0f, 0.92156f, 0.2f };
                    }
                    else if (normalX > 0.8f && normalX < 0.88f) {
                        selectedColour = { 1.0f, 0.57254f, 0.2f };
                    }
                    else if (normalX > 0.89f && normalX < 0.97f) {
                        selectedColour = { 1.0f, 0.80392f, 0.95294f };
                    }
                }
                else if (normalY < -0.3f && normalY > -0.5f) {
                    if (normalX > 0.62f && normalX < 0.73f) {
                        selectedBrush = "Triangle";
                    }
                    if (normalX > 0.74f && normalX < 0.85f) {
                        selectedBrush = "Square";
                    }
                    if (normalX > 0.86f && normalX < 0.97f) {
                        selectedBrush = "Circle";
                    }
                }
                else if (normalY < 0.2f && normalY > 0.0f) {
                    if (normalX > 0.62f && normalX < 0.73f) {
                        brushWidth = 5;
                    }
                    else if (normalX > 0.74f && normalX < 0.85f) {
                        brushWidth = 7;
                    }
                    else if (normalX > 0.86f && normalX < 0.97f) {
                        brushWidth = 10;
                    }
                }
                else if (normalY < 0.45f && normalY > 0.25f) {
                    if (normalX > 0.62f && normalX < 0.73f) {
                        brushWidth = 25;
                    }
                    else if (normalX > 0.74f && normalX < 0.85f) {
                        brushWidth = 50;
                    }
                    else if (normalX > 0.86f && normalX < 0.97f) {
                        brushWidth = 100;
                    }
                }

                else if (normalY > 0.5f && normalY < 0.7f && normalX ) {
                    vertices = defaultVertices;
                    indices = defaultIndices;
                    vertices.push_back({ {-1.0f, -1.0f}, selectedColour });
                    vertices.push_back({ {0.6f, -1.0f}, selectedColour });
                    vertices.push_back({ {0.6f, 1.0f}, selectedColour });
                    vertices.push_back({ {-1.0f, 1.0f}, selectedColour });
                    indices.push_back(vertices.size()-4);
                    indices.push_back(vertices.size()-3);
                    indices.push_back(vertices.size()-2);
                    indices.push_back(vertices.size()-2);
                    indices.push_back(vertices.size()-1);
                    indices.push_back(vertices.size()-4);


                    VkBuffer temp1 = vertexBuffer;
                    VkBuffer temp2 = indexBuffer;
                    VkDeviceMemory temp3 = vertexBufferMemory;
                    VkDeviceMemory temp4 = indexBufferMemory;
                    createVertexBuffer(vertices);
                    vkDestroyBuffer(device, temp1, nullptr);
                    vkFreeMemory(device, temp3, nullptr);
                    createIndexBuffer(indices);
                    vkDestroyBuffer(device, temp2, nullptr);
                    vkFreeMemory(device, temp4, nullptr);
                }

                
            }
        }
    }

    void squareBrushHandler(int x, int y) {
        glm::vec2 whatevervector = { normalize(x - (brushWidth / 2), width, true), normalize(y + ((brushWidth / 2)), height, false) };
        if (not (glm::all(glm::equal(vertices[vertices.size() - 1].pos,whatevervector)) && glm::all(glm::equal(vertices[vertices.size()-1].color,selectedColour)))) {
            vertices.push_back({ {normalize(x - (brushWidth / 2), width,true),normalize(y - (brushWidth / 2), height,false)}, selectedColour });
            vertices.push_back({ {normalize(x + (brushWidth / 2),width,true),normalize(y - ((brushWidth / 2)), height,false)}, selectedColour });
            vertices.push_back({ {normalize(x + (brushWidth / 2),width,true),normalize(y + ((brushWidth / 2)), height,false)}, selectedColour });
            vertices.push_back({ {normalize(x - (brushWidth / 2), width,true),normalize(y + ((brushWidth / 2)), height,false)}, selectedColour });

            indices.push_back(vertices.size() - 4);
            indices.push_back(vertices.size() - 3);
            indices.push_back(vertices.size() - 2);
            indices.push_back(vertices.size() - 2);
            indices.push_back(vertices.size() - 1);
            indices.push_back(vertices.size() - 4);
        }
    }

    void triangleBrushHandler(int x, int y) {
        glm::vec2 whateverVector = { normalize(x - (brushWidth / 2), width,true),normalize(y + ((brushWidth)*cos(30)), height,false)};
        if (not (glm::all(glm::equal(vertices[vertices.size() - 1].pos, whateverVector)) && glm::all(glm::equal(vertices[vertices.size() - 1].color, selectedColour)))) {
            vertices.push_back({ {normalize(x,width,true), normalize(y - (brushWidth / 2), height,false)}, selectedColour });
            vertices.push_back({ {normalize(x + (brushWidth / 2),width,true),normalize(y + ((brushWidth)*cos(30)), height,false)}, selectedColour });
            vertices.push_back({ {normalize(x - (brushWidth / 2), width,true),normalize(y + ((brushWidth)*cos(30)), height,false)}, selectedColour });

            indices.push_back(vertices.size() - 3);
            indices.push_back(vertices.size() - 2);
            indices.push_back(vertices.size() - 1);
        }
    }

    void circleBrushHandler(int x, int y) {
        //// Circle/Octogon Icon
        //{ { 0.87f, -0.40f }, { 0.0f,0.0f,0.0f } },      //0
        //{ {0.88125f, -0.455f}, {0.0f,0.0f,0.0f} },//1
        //{ {0.915f, -0.48f}, {0.0f,0.0f,0.0f} },     //2
        //{ {0.94875f, -0.455f}, {0.0f,0.0f,0.0f} },//3
        //{ {0.96f, -0.40f}, {0.0f,0.0f,0.0f} },      //4
        //{ {0.88125f, -0.34f}, {0.0f,0.0f,0.0f} },//5
        //{ {0.915f,-0.32f}, {0.0f,0.0f,0.0f} },      //6
        //{ {0.94875f, -0.34f}, {0.0f,0.0f,0.0f} },//7
        vertices.push_back({ {normalize(x - (brushWidth / 2),width, true),normalize(y,height,false)}, selectedColour });
        vertices.push_back({ {normalize(x - ((brushWidth / 2) * 0.75),width,true),normalize(y - ((brushWidth / 2) * 0.75),height,false)}, selectedColour });
        vertices.push_back({ {normalize(x,width,true),normalize(y-(brushWidth/2),height,false)}, selectedColour});
        vertices.push_back({ {normalize(x + ((brushWidth / 2) * 0.75),width,true),normalize(y - ((brushWidth / 2) * 0.75),height,false)}, selectedColour });
        vertices.push_back({ {normalize(x+(brushWidth/2),width,true),normalize(y,height,false)}, selectedColour});
        vertices.push_back({ {normalize(x - ((brushWidth / 2) * 0.75),width,true),normalize(y + ((brushWidth / 2) * 0.75),height,false)}, selectedColour });
        vertices.push_back({ {normalize(x,width,true),normalize(y + (brushWidth / 2),height,false)}, selectedColour });
        vertices.push_back({ {normalize(x+((brushWidth/2)*0.75),width,true),normalize(y+((brushWidth/2)*0.75),height,false)}, selectedColour});

        indices.push_back(vertices.size()-8);
        indices.push_back(vertices.size()-7);
        indices.push_back(vertices.size()-6);
        indices.push_back(vertices.size()-8);
        indices.push_back(vertices.size()-6);
        indices.push_back(vertices.size()-5);
        indices.push_back(vertices.size()-8);
        indices.push_back(vertices.size()-5);
        indices.push_back(vertices.size()-4);
        indices.push_back(vertices.size()-8);
        indices.push_back(vertices.size()-4);
        indices.push_back(vertices.size()-3);
        indices.push_back(vertices.size()-4);
        indices.push_back(vertices.size()-2);
        indices.push_back(vertices.size()-3);
        indices.push_back(vertices.size()-4);
        indices.push_back(vertices.size()-1);
        indices.push_back(vertices.size()-2);

        //std::cout << vertices[vertices.size() - 4].pos.x << "\n";
    }
    float normalize(int coordinate, int axis1, bool axis2) {
        float newcoordinate = (coordinate - (axis1 / 2.0)) / (axis1 / 2.0);

        if (newcoordinate > 0.6 && axis2) {
            newcoordinate = 0.6;
        }
        return newcoordinate;
    }

    float normalize2(int coordinate, int axis1) {
        float newcoordinate = (coordinate - (axis1 / 2.0)) / (axis1 / 2.0);

        return newcoordinate;
    }

    void cleanupSwapChain() {
        for (auto framebuffer : swapChainFramebuffers) {
            vkDestroyFramebuffer(device, framebuffer, nullptr);
        }

        for (auto imageView : swapChainImageViews) {
            vkDestroyImageView(device, imageView, nullptr);
        }

        vkDestroySwapchainKHR(device, swapChain, nullptr);
    }

    void cleanup() {
        cleanupSwapChain();

        vkDestroyPipeline(device, graphicsPipeline, nullptr);
        vkDestroyPipelineLayout(device, pipelineLayout, nullptr);
        vkDestroyRenderPass(device, renderPass, nullptr);

        vkDestroyBuffer(device, indexBuffer, nullptr);
        vkFreeMemory(device, indexBufferMemory, nullptr);

        vkDestroyBuffer(device, vertexBuffer, nullptr);
        vkFreeMemory(device, vertexBufferMemory, nullptr);


        for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
            vkDestroySemaphore(device, renderFinishedSemaphores[i], nullptr);
            vkDestroySemaphore(device, imageAvailableSemaphores[i], nullptr);
            vkDestroyFence(device, inFlightFences[i], nullptr);
        }

        vkDestroyCommandPool(device, commandPool, nullptr);

        vkDestroyDevice(device, nullptr);

        if (enableValidationLayers) {
            DestroyDebugUtilsMessengerEXT(instance, debugMessenger, nullptr);
        }

        vkDestroySurfaceKHR(instance, surface, nullptr);
        vkDestroyInstance(instance, nullptr);

        glfwDestroyWindow(window);

        glfwTerminate();
    }

    void recreateSwapChain() {
        int width = 0, height = 0;
        glfwGetFramebufferSize(window, &width, &height);
        while (width == 0 || height == 0) {
            glfwGetFramebufferSize(window, &width, &height);
            glfwWaitEvents();
        }

        vkDeviceWaitIdle(device);

        cleanupSwapChain();

        createSwapChain();
        createImageViews();
        createFramebuffers();
    }

    void createInstance() {
        if (enableValidationLayers && !checkValidationLayerSupport()) {
            throw std::runtime_error("validation layers requested, but not available!");
        }

        VkApplicationInfo appInfo{};
        appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
        appInfo.pApplicationName = "Hello Triangle";
        appInfo.applicationVersion = VK_MAKE_VERSION(1, 0, 0);
        appInfo.pEngineName = "No Engine";
        appInfo.engineVersion = VK_MAKE_VERSION(1, 0, 0);
        appInfo.apiVersion = VK_API_VERSION_1_0;

        VkInstanceCreateInfo createInfo{};
        createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
        createInfo.pApplicationInfo = &appInfo;

        auto extensions = getRequiredExtensions();
        createInfo.enabledExtensionCount = static_cast<uint32_t>(extensions.size());
        createInfo.ppEnabledExtensionNames = extensions.data();

        VkDebugUtilsMessengerCreateInfoEXT debugCreateInfo{};
        if (enableValidationLayers) {
            createInfo.enabledLayerCount = static_cast<uint32_t>(validationLayers.size());
            createInfo.ppEnabledLayerNames = validationLayers.data();

            populateDebugMessengerCreateInfo(debugCreateInfo);
            createInfo.pNext = (VkDebugUtilsMessengerCreateInfoEXT*)&debugCreateInfo;
        }
        else {
            createInfo.enabledLayerCount = 0;

            createInfo.pNext = nullptr;
        }

        if (vkCreateInstance(&createInfo, nullptr, &instance) != VK_SUCCESS) {
            throw std::runtime_error("failed to create instance!");
        }
    }

    void populateDebugMessengerCreateInfo(VkDebugUtilsMessengerCreateInfoEXT& createInfo) {
        createInfo = {};
        createInfo.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;
        createInfo.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;
        createInfo.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;
        createInfo.pfnUserCallback = debugCallback;
    }

    void setupDebugMessenger() {
        if (!enableValidationLayers) return;

        VkDebugUtilsMessengerCreateInfoEXT createInfo;
        populateDebugMessengerCreateInfo(createInfo);

        if (CreateDebugUtilsMessengerEXT(instance, &createInfo, nullptr, &debugMessenger) != VK_SUCCESS) {
            throw std::runtime_error("failed to set up debug messenger!");
        }
    }


    // Creates a Window Surface that we can draw on
    void createSurface() {
        if (glfwCreateWindowSurface(instance, window, nullptr, &surface) != VK_SUCCESS) {
            throw std::runtime_error("failed to create window surface!");
        }
    }

    // Chooses which GPU we're rendering with
    void pickPhysicalDevice() {
        uint32_t deviceCount = 0;
        vkEnumeratePhysicalDevices(instance, &deviceCount, nullptr);

        if (deviceCount == 0) {
            throw std::runtime_error("failed to find GPUs with Vulkan support!");
        }

        std::vector<VkPhysicalDevice> devices(deviceCount);
        vkEnumeratePhysicalDevices(instance, &deviceCount, devices.data());

        for (const auto& device : devices) {
            if (isDeviceSuitable(device)) {
                physicalDevice = device;
                break;
            }
        }

        if (physicalDevice == VK_NULL_HANDLE) {
            throw std::runtime_error("failed to find a suitable GPU!");
        }
    }

    // interface to be able to call functions onto the physical device?
    // something like that, basically code -> LogicalDevice > PhysicalDevice
    void createLogicalDevice() {
        QueueFamilyIndices indices = findQueueFamilies(physicalDevice);

        std::vector<VkDeviceQueueCreateInfo> queueCreateInfos;
        std::set<uint32_t> uniqueQueueFamilies = { indices.graphicsFamily.value(), indices.presentFamily.value() };

        float queuePriority = 1.0f;
        for (uint32_t queueFamily : uniqueQueueFamilies) {
            VkDeviceQueueCreateInfo queueCreateInfo{};
            queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
            queueCreateInfo.queueFamilyIndex = queueFamily;
            queueCreateInfo.queueCount = 1;
            queueCreateInfo.pQueuePriorities = &queuePriority;
            queueCreateInfos.push_back(queueCreateInfo);
        }

        VkPhysicalDeviceFeatures deviceFeatures{};

        VkDeviceCreateInfo createInfo{};
        createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;

        createInfo.queueCreateInfoCount = static_cast<uint32_t>(queueCreateInfos.size());
        createInfo.pQueueCreateInfos = queueCreateInfos.data();

        createInfo.pEnabledFeatures = &deviceFeatures;

        createInfo.enabledExtensionCount = static_cast<uint32_t>(deviceExtensions.size());
        createInfo.ppEnabledExtensionNames = deviceExtensions.data();

        if (enableValidationLayers) {
            createInfo.enabledLayerCount = static_cast<uint32_t>(validationLayers.size());
            createInfo.ppEnabledLayerNames = validationLayers.data();
        }
        else {
            createInfo.enabledLayerCount = 0;
        }

        if (vkCreateDevice(physicalDevice, &createInfo, nullptr, &device) != VK_SUCCESS) {
            throw std::runtime_error("failed to create logical device!");
        }

        vkGetDeviceQueue(device, indices.graphicsFamily.value(), 0, &graphicsQueue);
        vkGetDeviceQueue(device, indices.presentFamily.value(), 0, &presentQueue);
    }

    // creates our Swap Chain, which is a 'queue' of image that need to swapped and drawn onto screen
    void createSwapChain() {
        SwapChainSupportDetails swapChainSupport = querySwapChainSupport(physicalDevice);

        VkSurfaceFormatKHR surfaceFormat = chooseSwapSurfaceFormat(swapChainSupport.formats);
        VkPresentModeKHR presentMode = chooseSwapPresentMode(swapChainSupport.presentModes);
        VkExtent2D extent = chooseSwapExtent(swapChainSupport.capabilities);

        uint32_t imageCount = swapChainSupport.capabilities.minImageCount + 1;
        if (swapChainSupport.capabilities.maxImageCount > 0 && imageCount > swapChainSupport.capabilities.maxImageCount) {
            imageCount = swapChainSupport.capabilities.maxImageCount;
        }

        VkSwapchainCreateInfoKHR createInfo{};
        createInfo.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;
        createInfo.surface = surface;

        createInfo.minImageCount = imageCount;
        createInfo.imageFormat = surfaceFormat.format;
        createInfo.imageColorSpace = surfaceFormat.colorSpace;
        createInfo.imageExtent = extent;
        createInfo.imageArrayLayers = 1;
        createInfo.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;

        QueueFamilyIndices indices = findQueueFamilies(physicalDevice);
        uint32_t queueFamilyIndices[] = { indices.graphicsFamily.value(), indices.presentFamily.value() };

        if (indices.graphicsFamily != indices.presentFamily) {
            createInfo.imageSharingMode = VK_SHARING_MODE_CONCURRENT;
            createInfo.queueFamilyIndexCount = 2;
            createInfo.pQueueFamilyIndices = queueFamilyIndices;
        }
        else {
            createInfo.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE;
        }

        createInfo.preTransform = swapChainSupport.capabilities.currentTransform;
        createInfo.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;
        createInfo.presentMode = presentMode;
        createInfo.clipped = VK_TRUE;

        if (vkCreateSwapchainKHR(device, &createInfo, nullptr, &swapChain) != VK_SUCCESS) {
            throw std::runtime_error("failed to create swap chain!");
        }

        vkGetSwapchainImagesKHR(device, swapChain, &imageCount, nullptr);
        swapChainImages.resize(imageCount);
        vkGetSwapchainImagesKHR(device, swapChain, &imageCount, swapChainImages.data());

        swapChainImageFormat = surfaceFormat.format;
        swapChainExtent = extent;
    }

    void createImageViews() {
        swapChainImageViews.resize(swapChainImages.size());

        for (size_t i = 0; i < swapChainImages.size(); i++) {
            VkImageViewCreateInfo createInfo{};
            createInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
            createInfo.image = swapChainImages[i];
            createInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
            createInfo.format = swapChainImageFormat;
            createInfo.components.r = VK_COMPONENT_SWIZZLE_IDENTITY;
            createInfo.components.g = VK_COMPONENT_SWIZZLE_IDENTITY;
            createInfo.components.b = VK_COMPONENT_SWIZZLE_IDENTITY;
            createInfo.components.a = VK_COMPONENT_SWIZZLE_IDENTITY;
            createInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
            createInfo.subresourceRange.baseMipLevel = 0;
            createInfo.subresourceRange.levelCount = 1;
            createInfo.subresourceRange.baseArrayLayer = 0;
            createInfo.subresourceRange.layerCount = 1;

            if (vkCreateImageView(device, &createInfo, nullptr, &swapChainImageViews[i]) != VK_SUCCESS) {
                throw std::runtime_error("failed to create image views!");
            }
        }
    }

    void createRenderPass() {
        VkAttachmentDescription colorAttachment{};
        colorAttachment.format = swapChainImageFormat;
        colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT;
        colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
        colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
        colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
        colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
        colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
        colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;

        VkAttachmentReference colorAttachmentRef{};
        colorAttachmentRef.attachment = 0;
        colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

        VkSubpassDescription subpass{};
        subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
        subpass.colorAttachmentCount = 1;
        subpass.pColorAttachments = &colorAttachmentRef;

        VkSubpassDependency dependency{};
        dependency.srcSubpass = VK_SUBPASS_EXTERNAL;
        dependency.dstSubpass = 0;
        dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
        dependency.srcAccessMask = 0;
        dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
        dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;

        VkRenderPassCreateInfo renderPassInfo{};
        renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
        renderPassInfo.attachmentCount = 1;
        renderPassInfo.pAttachments = &colorAttachment;
        renderPassInfo.subpassCount = 1;
        renderPassInfo.pSubpasses = &subpass;
        renderPassInfo.dependencyCount = 1;
        renderPassInfo.pDependencies = &dependency;

        if (vkCreateRenderPass(device, &renderPassInfo, nullptr, &renderPass) != VK_SUCCESS) {
            throw std::runtime_error("failed to create render pass!");
        }
    }
    // I belive that modularizing the buffer functions will let us 
    void createGraphicsPipeline() {
        auto vertShaderCode = readFile("shaders/vert.spv");
        auto fragShaderCode = readFile("shaders/frag.spv");


        // vertex shader applies transformations to vertex positions from model space to screen space, passing per-vertex data
        VkShaderModule vertShaderModule = createShaderModule(vertShaderCode);
        // Rasterization turns primitives into fragments, which are pixel elements that they fill on the frame buffer, any fragments
        // that fall out of the screen are discarded and usually fragments that are behind other primitives are discarded.
        // the fragment shader is invoked for every fragment shader that survives and determines which framebuffers they are written to.
        VkShaderModule fragShaderModule = createShaderModule(fragShaderCode);

        VkPipelineShaderStageCreateInfo vertShaderStageInfo{};
        vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
        vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
        vertShaderStageInfo.module = vertShaderModule;
        vertShaderStageInfo.pName = "main";

        VkPipelineShaderStageCreateInfo fragShaderStageInfo{};
        fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
        fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;
        fragShaderStageInfo.module = fragShaderModule;
        fragShaderStageInfo.pName = "main";

        VkPipelineShaderStageCreateInfo shaderStages[] = { vertShaderStageInfo, fragShaderStageInfo };

        VkPipelineVertexInputStateCreateInfo vertexInputInfo{};
        vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;

        auto bindingDescription = Vertex::getBindingDescription();
        auto attributeDescriptions = Vertex::getAttributeDescriptions();

        vertexInputInfo.vertexBindingDescriptionCount = 1;
        vertexInputInfo.vertexAttributeDescriptionCount = static_cast<uint32_t>(attributeDescriptions.size());
        vertexInputInfo.pVertexBindingDescriptions = &bindingDescription;
        vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions.data();

        VkPipelineInputAssemblyStateCreateInfo inputAssembly{};
        inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
        inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
        inputAssembly.primitiveRestartEnable = VK_FALSE;

        VkPipelineViewportStateCreateInfo viewportState{};
        viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
        viewportState.viewportCount = 1;
        viewportState.scissorCount = 1;

        VkPipelineRasterizationStateCreateInfo rasterizer{};
        rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
        rasterizer.depthClampEnable = VK_FALSE;
        rasterizer.rasterizerDiscardEnable = VK_FALSE;
        rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
        rasterizer.lineWidth = 1.0f;
        rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
        rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE;
        rasterizer.depthBiasEnable = VK_FALSE;

        VkPipelineMultisampleStateCreateInfo multisampling{};
        multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
        multisampling.sampleShadingEnable = VK_FALSE;
        multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;

        VkPipelineColorBlendAttachmentState colorBlendAttachment{};
        colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
        colorBlendAttachment.blendEnable = VK_FALSE;

        VkPipelineColorBlendStateCreateInfo colorBlending{};
        colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
        colorBlending.logicOpEnable = VK_FALSE;
        colorBlending.logicOp = VK_LOGIC_OP_COPY;
        colorBlending.attachmentCount = 1;
        colorBlending.pAttachments = &colorBlendAttachment;
        colorBlending.blendConstants[0] = 0.0f;
        colorBlending.blendConstants[1] = 0.0f;
        colorBlending.blendConstants[2] = 0.0f;
        colorBlending.blendConstants[3] = 0.0f;

        std::vector<VkDynamicState> dynamicStates = {
            VK_DYNAMIC_STATE_VIEWPORT,
            VK_DYNAMIC_STATE_SCISSOR
        };
        VkPipelineDynamicStateCreateInfo dynamicState{};
        dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
        dynamicState.dynamicStateCount = static_cast<uint32_t>(dynamicStates.size());
        dynamicState.pDynamicStates = dynamicStates.data();

        VkPipelineLayoutCreateInfo pipelineLayoutInfo{};
        pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
        pipelineLayoutInfo.setLayoutCount = 0;
        pipelineLayoutInfo.pushConstantRangeCount = 0;

        if (vkCreatePipelineLayout(device, &pipelineLayoutInfo, nullptr, &pipelineLayout) != VK_SUCCESS) {
            throw std::runtime_error("failed to create pipeline layout!");
        }

        VkGraphicsPipelineCreateInfo pipelineInfo{};
        pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
        pipelineInfo.stageCount = 2;
        pipelineInfo.pStages = shaderStages;
        pipelineInfo.pVertexInputState = &vertexInputInfo;
        pipelineInfo.pInputAssemblyState = &inputAssembly;
        pipelineInfo.pViewportState = &viewportState;
        pipelineInfo.pRasterizationState = &rasterizer;
        pipelineInfo.pMultisampleState = &multisampling;
        pipelineInfo.pColorBlendState = &colorBlending;
        pipelineInfo.pDynamicState = &dynamicState;
        pipelineInfo.layout = pipelineLayout;
        pipelineInfo.renderPass = renderPass;
        pipelineInfo.subpass = 0;
        pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;

        if (vkCreateGraphicsPipelines(device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &graphicsPipeline) != VK_SUCCESS) {
            throw std::runtime_error("failed to create graphics pipeline!");
        }

        vkDestroyShaderModule(device, fragShaderModule, nullptr);
        vkDestroyShaderModule(device, vertShaderModule, nullptr);
    }
    
    void createFramebuffers() {
        swapChainFramebuffers.resize(swapChainImageViews.size());

        for (size_t i = 0; i < swapChainImageViews.size(); i++) {
            VkImageView attachments[] = {
                swapChainImageViews[i]
            };

            VkFramebufferCreateInfo framebufferInfo{};
            framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
            framebufferInfo.renderPass = renderPass;
            framebufferInfo.attachmentCount = 1;
            framebufferInfo.pAttachments = attachments;
            framebufferInfo.width = swapChainExtent.width;
            framebufferInfo.height = swapChainExtent.height;
            framebufferInfo.layers = 1;

            if (vkCreateFramebuffer(device, &framebufferInfo, nullptr, &swapChainFramebuffers[i]) != VK_SUCCESS) {
                throw std::runtime_error("failed to create framebuffer!");
            }
        }
    }

    void createCommandPool() {
        QueueFamilyIndices queueFamilyIndices = findQueueFamilies(physicalDevice);

        VkCommandPoolCreateInfo poolInfo{};
        poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
        poolInfo.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;
        poolInfo.queueFamilyIndex = queueFamilyIndices.graphicsFamily.value();

        if (vkCreateCommandPool(device, &poolInfo, nullptr, &commandPool) != VK_SUCCESS) {
            throw std::runtime_error("failed to create graphics command pool!");
        }
    }

    void createVertexBuffer(std::vector<Vertex >vertices) {
        VkDeviceSize bufferSize = sizeof(vertices[0]) * vertices.size();

        VkBuffer stagingBuffer;
        VkDeviceMemory stagingBufferMemory;
        createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, stagingBufferMemory);

        void* data;
        vkMapMemory(device, stagingBufferMemory, 0, bufferSize, 0, &data);
        memcpy(data, vertices.data(), (size_t)bufferSize);
        vkUnmapMemory(device, stagingBufferMemory);

        createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, vertexBuffer, vertexBufferMemory);

        copyBuffer(stagingBuffer, vertexBuffer, bufferSize);

        vkDestroyBuffer(device, stagingBuffer, nullptr);
        vkFreeMemory(device, stagingBufferMemory, nullptr);

    }

    VkBuffer createVertexBuffer(std::vector<Vertex >vertices, VkBuffer buffer, VkDeviceMemory memory) {
        VkDeviceSize bufferSize = sizeof(vertices[0]) * vertices.size();

        VkBuffer stagingBuffer;
        VkDeviceMemory stagingBufferMemory;
        createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, stagingBufferMemory);

        void* data;
        vkMapMemory(device, stagingBufferMemory, 0, bufferSize, 0, &data);
        memcpy(data, vertices.data(), (size_t)bufferSize);
        vkUnmapMemory(device, stagingBufferMemory);

        createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, buffer, memory);

        copyBuffer(stagingBuffer, buffer, bufferSize);

        vkDestroyBuffer(device, stagingBuffer, nullptr);
        vkFreeMemory(device, stagingBufferMemory, nullptr);

        return buffer;

    }

    void createIndexBuffer(std::vector<uint32_t> indices) {
        VkDeviceSize bufferSize = sizeof(indices[0]) * indices.size();

        VkBuffer stagingBuffer;
        VkDeviceMemory stagingBufferMemory;
        createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, stagingBufferMemory);

        void* data;
        vkMapMemory(device, stagingBufferMemory, 0, bufferSize, 0, &data);
        memcpy(data, indices.data(), (size_t)bufferSize);
        vkUnmapMemory(device, stagingBufferMemory);

        createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_INDEX_BUFFER_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, indexBuffer, indexBufferMemory);

        copyBuffer(stagingBuffer, indexBuffer, bufferSize);

        vkDestroyBuffer(device, stagingBuffer, nullptr);
        vkFreeMemory(device, stagingBufferMemory, nullptr);
    }


    VkBuffer createIndexBuffer(std::vector<uint32_t> indices, VkBuffer buffer, VkDeviceMemory memory) {
        VkDeviceSize bufferSize = sizeof(indices[0]) * indices.size();

        VkBuffer stagingBuffer;
        VkDeviceMemory stagingBufferMemory;
        createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, stagingBufferMemory);

        void* data;
        vkMapMemory(device, stagingBufferMemory, 0, bufferSize, 0, &data);
        memcpy(data, indices.data(), (size_t)bufferSize);
        vkUnmapMemory(device, stagingBufferMemory);

        createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_INDEX_BUFFER_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, buffer, memory);

        copyBuffer(stagingBuffer, buffer, bufferSize);

        vkDestroyBuffer(device, stagingBuffer, nullptr);
        vkFreeMemory(device, stagingBufferMemory, nullptr);

        return buffer;
    }

    void createBuffer(VkDeviceSize size, VkBufferUsageFlags usage, VkMemoryPropertyFlags properties, VkBuffer& buffer, VkDeviceMemory& bufferMemory) {
        VkBufferCreateInfo bufferInfo{};
        bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
        bufferInfo.size = size;
        bufferInfo.usage = usage;
        bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;

        if (vkCreateBuffer(device, &bufferInfo, nullptr, &buffer) != VK_SUCCESS) {
            throw std::runtime_error("failed to create buffer!");
        }

        VkMemoryRequirements memRequirements;
        vkGetBufferMemoryRequirements(device, buffer, &memRequirements);

        VkMemoryAllocateInfo allocInfo{};
        allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
        allocInfo.allocationSize = memRequirements.size;
        allocInfo.memoryTypeIndex = findMemoryType(memRequirements.memoryTypeBits, properties);

        if (vkAllocateMemory(device, &allocInfo, nullptr, &bufferMemory) != VK_SUCCESS) {
            throw std::runtime_error("failed to allocate buffer memory!");
        }

        vkBindBufferMemory(device, buffer, bufferMemory, 0);
    }


    void copyBuffer(VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size) {
        VkCommandBufferAllocateInfo allocInfo{};
        allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
        allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
        allocInfo.commandPool = commandPool;
        allocInfo.commandBufferCount = 1;

        VkCommandBuffer commandBuffer;
        vkAllocateCommandBuffers(device, &allocInfo, &commandBuffer);

        VkCommandBufferBeginInfo beginInfo{};
        beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
        beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;

        vkBeginCommandBuffer(commandBuffer, &beginInfo);

        VkBufferCopy copyRegion{};
        copyRegion.size = size;
        vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, 1, &copyRegion);

        vkEndCommandBuffer(commandBuffer);

        VkSubmitInfo submitInfo{};
        submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
        submitInfo.commandBufferCount = 1;
        submitInfo.pCommandBuffers = &commandBuffer;

        vkQueueSubmit(graphicsQueue, 1, &submitInfo, VK_NULL_HANDLE);
        vkQueueWaitIdle(graphicsQueue);

        vkFreeCommandBuffers(device, commandPool, 1, &commandBuffer);
    }

    uint32_t findMemoryType(uint32_t typeFilter, VkMemoryPropertyFlags properties) {
        VkPhysicalDeviceMemoryProperties memProperties;
        vkGetPhysicalDeviceMemoryProperties(physicalDevice, &memProperties);

        for (uint32_t i = 0; i < memProperties.memoryTypeCount; i++) {
            if ((typeFilter & (1 << i)) && (memProperties.memoryTypes[i].propertyFlags & properties) == properties) {
                return i;
            }
        }

        throw std::runtime_error("failed to find suitable memory type!");
    }

    void createCommandBuffers() {
        commandBuffers.resize(MAX_FRAMES_IN_FLIGHT);

        VkCommandBufferAllocateInfo allocInfo{};
        allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
        allocInfo.commandPool = commandPool;
        allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
        allocInfo.commandBufferCount = (uint32_t)commandBuffers.size();

        if (vkAllocateCommandBuffers(device, &allocInfo, commandBuffers.data()) != VK_SUCCESS) {
            throw std::runtime_error("failed to allocate command buffers!");
        }
    }

    void recordCommandBuffer(VkCommandBuffer commandBuffer, uint32_t imageIndex) {
        VkCommandBufferBeginInfo beginInfo{};
        beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;

        if (vkBeginCommandBuffer(commandBuffer, &beginInfo) != VK_SUCCESS) {
            throw std::runtime_error("failed to begin recording command buffer!");
        }

        VkRenderPassBeginInfo renderPassInfo{};
        renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
        renderPassInfo.renderPass = renderPass;
        renderPassInfo.framebuffer = swapChainFramebuffers[imageIndex];
        renderPassInfo.renderArea.offset = { 0, 0 };
        renderPassInfo.renderArea.extent = swapChainExtent;

        VkClearValue clearColor = { {{0.0f, 0.0f, 0.0f, 0.0f}} };
        renderPassInfo.clearValueCount = 1;
        renderPassInfo.pClearValues = &clearColor;

        vkCmdBeginRenderPass(commandBuffer, &renderPassInfo, VK_SUBPASS_CONTENTS_INLINE);

        vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);

        VkViewport viewport{};
        viewport.x = 0.0f;
        viewport.y = 0.0f;
        viewport.width = (float)swapChainExtent.width;
        viewport.height = (float)swapChainExtent.height;
        viewport.minDepth = 0.0f;
        viewport.maxDepth = 1.0f;
        vkCmdSetViewport(commandBuffer, 0, 1, &viewport);

        VkRect2D scissor{};
        scissor.offset = { 0, 0 };
        scissor.extent = swapChainExtent;
        vkCmdSetScissor(commandBuffer, 0, 1, &scissor);

        VkBuffer vertexBuffers[] = { vertexBuffer};
        VkDeviceSize offsets[] = { 0};
        vkCmdBindVertexBuffers(commandBuffer, 0, 1, vertexBuffers, offsets);

        vkCmdBindIndexBuffer(commandBuffer, indexBuffer, 0, VK_INDEX_TYPE_UINT32);

        vkCmdDrawIndexed(commandBuffer, static_cast<uint32_t>(indices.size()), 1, 0, 0, 0);

        vkCmdEndRenderPass(commandBuffer);

        if (vkEndCommandBuffer(commandBuffer) != VK_SUCCESS) {
            throw std::runtime_error("failed to record command buffer!");
        }
    }

    void createSyncObjects() {
        imageAvailableSemaphores.resize(MAX_FRAMES_IN_FLIGHT);
        renderFinishedSemaphores.resize(MAX_FRAMES_IN_FLIGHT);
        inFlightFences.resize(MAX_FRAMES_IN_FLIGHT);

        VkSemaphoreCreateInfo semaphoreInfo{};
        semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;

        VkFenceCreateInfo fenceInfo{};
        fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
        fenceInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;

        for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) {
            if (vkCreateSemaphore(device, &semaphoreInfo, nullptr, &imageAvailableSemaphores[i]) != VK_SUCCESS ||
                vkCreateSemaphore(device, &semaphoreInfo, nullptr, &renderFinishedSemaphores[i]) != VK_SUCCESS ||
                vkCreateFence(device, &fenceInfo, nullptr, &inFlightFences[i]) != VK_SUCCESS) {
                throw std::runtime_error("failed to create synchronization objects for a frame!");
            }
        }
    }

    void drawFrame() {
        vkWaitForFences(device, 1, &inFlightFences[currentFrame], VK_TRUE, UINT64_MAX);

        uint32_t imageIndex;
        VkResult result = vkAcquireNextImageKHR(device, swapChain, UINT64_MAX, imageAvailableSemaphores[currentFrame], VK_NULL_HANDLE, &imageIndex);

        if (result == VK_ERROR_OUT_OF_DATE_KHR) {
            recreateSwapChain();
            return;
        }
        else if (result != VK_SUCCESS && result != VK_SUBOPTIMAL_KHR) {
            throw std::runtime_error("failed to acquire swap chain image!");
        }

        vkResetFences(device, 1, &inFlightFences[currentFrame]);

        vkResetCommandBuffer(commandBuffers[currentFrame], /*VkCommandBufferResetFlagBits*/ 0);
        recordCommandBuffer(commandBuffers[currentFrame], imageIndex);

        VkSubmitInfo submitInfo{};
        submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;

        VkSemaphore waitSemaphores[] = { imageAvailableSemaphores[currentFrame] };
        VkPipelineStageFlags waitStages[] = { VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT };
        submitInfo.waitSemaphoreCount = 1;
        submitInfo.pWaitSemaphores = waitSemaphores;
        submitInfo.pWaitDstStageMask = waitStages;

        submitInfo.commandBufferCount = 1;
        submitInfo.pCommandBuffers = &commandBuffers[currentFrame];

        VkSemaphore signalSemaphores[] = { renderFinishedSemaphores[currentFrame] };
        submitInfo.signalSemaphoreCount = 1;
        submitInfo.pSignalSemaphores = signalSemaphores;

        if (vkQueueSubmit(graphicsQueue, 1, &submitInfo, inFlightFences[currentFrame]) != VK_SUCCESS) {
            throw std::runtime_error("failed to submit draw command buffer!");
        }

        VkPresentInfoKHR presentInfo{};
        presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;

        presentInfo.waitSemaphoreCount = 1;
        presentInfo.pWaitSemaphores = signalSemaphores;

        VkSwapchainKHR swapChains[] = { swapChain };
        presentInfo.swapchainCount = 1;
        presentInfo.pSwapchains = swapChains;

        presentInfo.pImageIndices = &imageIndex;

        result = vkQueuePresentKHR(presentQueue, &presentInfo);

        if (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR || framebufferResized) {
            framebufferResized = false;
            recreateSwapChain();
        }
        else if (result != VK_SUCCESS) {
            throw std::runtime_error("failed to present swap chain image!");
        }


        currentFrame = (currentFrame + 1) % MAX_FRAMES_IN_FLIGHT;
    }

    // Helper function in creating shader modules
    VkShaderModule createShaderModule(const std::vector<char>& code) {
        VkShaderModuleCreateInfo createInfo{};
        createInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
        createInfo.codeSize = code.size();
        createInfo.pCode = reinterpret_cast<const uint32_t*>(code.data());

        VkShaderModule shaderModule;
        if (vkCreateShaderModule(device, &createInfo, nullptr, &shaderModule) != VK_SUCCESS) {
            throw std::runtime_error("failed to create shader module!");
        }

        return shaderModule;
    }

    VkSurfaceFormatKHR chooseSwapSurfaceFormat(const std::vector<VkSurfaceFormatKHR>& availableFormats) {
        for (const auto& availableFormat : availableFormats) {
            if (availableFormat.format == VK_FORMAT_B8G8R8A8_SRGB && availableFormat.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) {
                return availableFormat;
            }
        }

        return availableFormats[0];
    }

    VkPresentModeKHR chooseSwapPresentMode(const std::vector<VkPresentModeKHR>& availablePresentModes) {
        for (const auto& availablePresentMode : availablePresentModes) {
            if (availablePresentMode == VK_PRESENT_MODE_MAILBOX_KHR) {
                return availablePresentMode;
            }
        }

        return VK_PRESENT_MODE_FIFO_KHR;
    }

    VkExtent2D chooseSwapExtent(const VkSurfaceCapabilitiesKHR& capabilities) {
        if (capabilities.currentExtent.width != std::numeric_limits<uint32_t>::max()) {
            return capabilities.currentExtent;
        }
        else {
            int width, height;
            glfwGetFramebufferSize(window, &width, &height);

            VkExtent2D actualExtent = {
                static_cast<uint32_t>(width),
                static_cast<uint32_t>(height)
            };

            actualExtent.width = std::clamp(actualExtent.width, capabilities.minImageExtent.width, capabilities.maxImageExtent.width);
            actualExtent.height = std::clamp(actualExtent.height, capabilities.minImageExtent.height, capabilities.maxImageExtent.height);

            return actualExtent;
        }
    }

    SwapChainSupportDetails querySwapChainSupport(VkPhysicalDevice device) {
        SwapChainSupportDetails details;

        vkGetPhysicalDeviceSurfaceCapabilitiesKHR(device, surface, &details.capabilities);

        uint32_t formatCount;
        vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &formatCount, nullptr);

        if (formatCount != 0) {
            details.formats.resize(formatCount);
            vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &formatCount, details.formats.data());
        }

        uint32_t presentModeCount;
        vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &presentModeCount, nullptr);

        if (presentModeCount != 0) {
            details.presentModes.resize(presentModeCount);
            vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &presentModeCount, details.presentModes.data());
        }

        return details;
    }

    bool isDeviceSuitable(VkPhysicalDevice device) {
        QueueFamilyIndices indices = findQueueFamilies(device);

        bool extensionsSupported = checkDeviceExtensionSupport(device);

        bool swapChainAdequate = false;
        if (extensionsSupported) {
            SwapChainSupportDetails swapChainSupport = querySwapChainSupport(device);
            swapChainAdequate = !swapChainSupport.formats.empty() && !swapChainSupport.presentModes.empty();
        }

        return indices.isComplete() && extensionsSupported && swapChainAdequate;
    }

    bool checkDeviceExtensionSupport(VkPhysicalDevice device) {
        uint32_t extensionCount;
        vkEnumerateDeviceExtensionProperties(device, nullptr, &extensionCount, nullptr);

        std::vector<VkExtensionProperties> availableExtensions(extensionCount);
        vkEnumerateDeviceExtensionProperties(device, nullptr, &extensionCount, availableExtensions.data());

        std::set<std::string> requiredExtensions(deviceExtensions.begin(), deviceExtensions.end());

        for (const auto& extension : availableExtensions) {
            requiredExtensions.erase(extension.extensionName);
        }

        return requiredExtensions.empty();
    }

    QueueFamilyIndices findQueueFamilies(VkPhysicalDevice device) {
        QueueFamilyIndices indices;

        uint32_t queueFamilyCount = 0;
        vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, nullptr);

        std::vector<VkQueueFamilyProperties> queueFamilies(queueFamilyCount);
        vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, queueFamilies.data());

        int i = 0;
        for (const auto& queueFamily : queueFamilies) {
            if (queueFamily.queueFlags & VK_QUEUE_GRAPHICS_BIT) {
                indices.graphicsFamily = i;
            }

            VkBool32 presentSupport = false;
            vkGetPhysicalDeviceSurfaceSupportKHR(device, i, surface, &presentSupport);

            if (presentSupport) {
                indices.presentFamily = i;
            }

            if (indices.isComplete()) {
                break;
            }

            i++;
        }

        return indices;
    }

    std::vector<const char*> getRequiredExtensions() {
        uint32_t glfwExtensionCount = 0;
        const char** glfwExtensions;
        glfwExtensions = glfwGetRequiredInstanceExtensions(&glfwExtensionCount);

        std::vector<const char*> extensions(glfwExtensions, glfwExtensions + glfwExtensionCount);

        if (enableValidationLayers) {
            extensions.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);
        }

        return extensions;
    }

    bool checkValidationLayerSupport() {
        uint32_t layerCount;
        vkEnumerateInstanceLayerProperties(&layerCount, nullptr);

        std::vector<VkLayerProperties> availableLayers(layerCount);
        vkEnumerateInstanceLayerProperties(&layerCount, availableLayers.data());

        for (const char* layerName : validationLayers) {
            bool layerFound = false;

            for (const auto& layerProperties : availableLayers) {
                if (strcmp(layerName, layerProperties.layerName) == 0) {
                    layerFound = true;
                    break;
                }
            }

            if (!layerFound) {
                return false;
            }
        }

        return true;
    }

    static std::vector<char> readFile(const std::string& filename) {
        std::ifstream file(filename, std::ios::ate | std::ios::binary);

        if (!file.is_open()) {
            throw std::runtime_error("failed to open file!");
        }

        size_t fileSize = (size_t)file.tellg();
        std::vector<char> buffer(fileSize);

        file.seekg(0);
        file.read(buffer.data(), fileSize);

        file.close();

        return buffer;
    }

    static VKAPI_ATTR VkBool32 VKAPI_CALL debugCallback(VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageType, const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData, void* pUserData) {
        std::cerr << "validation layer: " << pCallbackData->pMessage << std::endl;

        return VK_FALSE;
    }
};

int main() {
    HelloTriangleApplication app;

    try {
        app.run();
    }
    catch (const std::exception& e) {
        std::cerr << e.what() << std::endl;
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}